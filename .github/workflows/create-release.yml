name: Create Release

# The run-name will show what was selected at trigger time
run-name: "Create Release: ${{ github.event.inputs.version_mode == 'manual' && github.event.inputs.manual_version || 'Auto-increment' }} - ${{ github.event.inputs.app_selection == 'all' && 'All apps' || github.event.inputs.specific_app }}"

on:
  workflow_dispatch:
    inputs:
      app_selection:
        description: 'App selection mode'
        required: true
        type: choice
        options:
          - all
          - specific
        default: all
      
      specific_app:
        description: 'Specific app name (only used if app_selection is "specific")'
        required: false
        type: choice
        options:
          - ev.energy
          - NGMA
          - NGNY
          - SVCE
          - MCE
          - ANWB
        default: ev.energy
      
      version_mode:
        description: 'Version mode'
        required: true
        type: choice
        options:
          - automatic
          - manual
        default: automatic
      
      manual_version:
        description: 'Manual version override (e.g., v3.29.0) - only used if version_mode is "manual"'
        required: false
        type: string

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.determine-version.outputs.version }}
      apps: ${{ steps.determine-apps.outputs.apps }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags
      
      - name: Determine version
        id: determine-version
        run: |
          if [ "${{ github.event.inputs.version_mode }}" == "manual" ]; then
            # Use manual version
            VERSION="${{ github.event.inputs.manual_version }}"
            
            # Validate format
            if ! echo "$VERSION" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' > /dev/null; then
              echo "Error: Invalid version format. Expected format: vX.Y.Z (e.g., v3.28.0)"
              exit 1
            fi
            
            echo "Using manual version: $VERSION"
            LATEST_TAG=$(git tag -l "v*.*.*" | sort -V | tail -n 1)
          else
            # Get the latest tag that matches version pattern
            LATEST_TAG=$(git tag -l "v*.*.*" | sort -V | tail -n 1)
            
            if [ -z "$LATEST_TAG" ]; then
              # No previous tags found, start with v1.0.0
              VERSION="v1.0.0"
              echo "No previous tags found. Starting with $VERSION"
            else
              echo "Latest tag found: $LATEST_TAG"
              
              # Extract version numbers
              VERSION_WITHOUT_V=${LATEST_TAG#v}
              IFS='.' read -ra VERSION_PARTS <<< "$VERSION_WITHOUT_V"
              
              MAJOR=${VERSION_PARTS[0]}
              MINOR=${VERSION_PARTS[1]}
              PATCH=${VERSION_PARTS[2]}
              
              # Increment minor version and reset patch
              NEW_MINOR=$((MINOR + 1))
              VERSION="v${MAJOR}.${NEW_MINOR}.0"
              
              echo "Incremented version from $LATEST_TAG to $VERSION"
            fi
          fi
          
          # Validate that new version is higher than the latest
          if [ -n "$LATEST_TAG" ]; then
            # Compare versions
            LATEST_TAG_FOR_COMPARE=${LATEST_TAG#v}
            VERSION_FOR_COMPARE=${VERSION#v}
            
            # Use sort -V to compare versions
            HIGHER_VERSION=$(printf '%s\n%s' "$LATEST_TAG_FOR_COMPARE" "$VERSION_FOR_COMPARE" | sort -V | tail -n 1)
            
            if [ "$HIGHER_VERSION" != "$VERSION_FOR_COMPARE" ]; then
              echo "Error: New version $VERSION is not higher than latest tag $LATEST_TAG"
              exit 1
            fi
            
            if [ "$HIGHER_VERSION" == "$LATEST_TAG_FOR_COMPARE" ] && [ "$VERSION_FOR_COMPARE" == "$LATEST_TAG_FOR_COMPARE" ]; then
              echo "Error: New version $VERSION is the same as latest tag $LATEST_TAG"
              exit 1
            fi
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "✅ Version validated: $VERSION"
          
          # Display prominent banner with actual version
          echo ""
          echo "╔════════════════════════════════════════╗"
          echo "║     RELEASE VERSION: $VERSION         "
          echo "╚════════════════════════════════════════╝"
          echo ""
      
      - name: Determine apps to build
        id: determine-apps
        run: |
          if [ "${{ github.event.inputs.app_selection }}" == "all" ]; then
            APPS='["ev.energy", "NGMA", "NGNY", "SVCE", "MCE", "ANWB"]'
            echo "Building all apps"
          else
            APPS='["${{ github.event.inputs.specific_app }}"]'
            echo "Building specific app: ${{ github.event.inputs.specific_app }}"
          fi
          
          echo "apps=$APPS" >> $GITHUB_OUTPUT
      
      - name: Display release information
        run: |
          echo "========================================="
          echo "📦 RELEASE INFORMATION"
          echo "========================================="
          echo "Version: ${{ steps.determine-version.outputs.version }}"
          echo "Apps to build: ${{ steps.determine-apps.outputs.apps }}"
          echo "========================================="
          
          # Parse and display apps in a readable format
          APPS='${{ steps.determine-apps.outputs.apps }}'
          echo ""
          echo "Apps list:"
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "  - $app"
          done
          echo ""
          echo "========================================="
  
  create-release:
    needs: prepare-release
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for creating releases and tags
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Generate release notes
        id: release-notes
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          APPS='${{ needs.prepare-release.outputs.apps }}'
          
          # Get the previous tag for comparison
          PREVIOUS_TAG=$(git tag -l "v*.*.*" | sort -V | tail -n 2 | head -n 1)
          
          # If no previous tag, use the initial commit
          if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" == "$VERSION" ]; then
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
            echo "No previous tag found, using initial commit"
          else
            echo "Previous tag: $PREVIOUS_TAG"
          fi
          
          # Create release notes
          cat > release_notes.md << EOF
          ## 📦 Apps Included
          EOF
          
          # Add apps to release notes
          if [ "${{ github.event.inputs.app_selection }}" == "all" ]; then
            echo "**All applications:**" >> release_notes.md
          else
            echo "**Single application:**" >> release_notes.md
          fi
          
          echo '```' >> release_notes.md
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "• $app" >> release_notes.md
          done
          echo '```' >> release_notes.md
          
          cat >> release_notes.md << EOF
          
          ## 🔧 Build Information
          - **Version Mode**: ${{ github.event.inputs.version_mode }}
          - **Triggered by**: @${{ github.actor }}
          - **Build Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **Workflow Run**: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ## 🎯 What's Changed
          EOF
          
          # Get commit count
          COMMIT_COUNT=$(git rev-list --count ${PREVIOUS_TAG}..HEAD)
          echo "**${COMMIT_COUNT} commits** since ${PREVIOUS_TAG}" >> release_notes.md
          echo "" >> release_notes.md
          
          # Group commits by type (feat, fix, chore, etc.)
          echo "### ✨ Features" >> release_notes.md
          git log ${PREVIOUS_TAG}..HEAD --pretty=format:"* %s (%h) - @%an" --grep="^feat" >> release_notes.md || echo "* No new features" >> release_notes.md
          echo "" >> release_notes.md
          echo "" >> release_notes.md
          
          echo "### 🐛 Bug Fixes" >> release_notes.md
          git log ${PREVIOUS_TAG}..HEAD --pretty=format:"* %s (%h) - @%an" --grep="^fix" >> release_notes.md || echo "* No bug fixes" >> release_notes.md
          echo "" >> release_notes.md
          echo "" >> release_notes.md
          
          echo "### 📚 Documentation" >> release_notes.md
          git log ${PREVIOUS_TAG}..HEAD --pretty=format:"* %s (%h) - @%an" --grep="^docs" >> release_notes.md || echo "* No documentation updates" >> release_notes.md
          echo "" >> release_notes.md
          echo "" >> release_notes.md
          
          echo "### 🔧 Other Changes" >> release_notes.md
          git log ${PREVIOUS_TAG}..HEAD --pretty=format:"* %s (%h) - @%an" --grep -v "^feat" --grep -v "^fix" --grep -v "^docs" | head -10 >> release_notes.md || echo "* No other changes" >> release_notes.md
          echo "" >> release_notes.md
          echo "" >> release_notes.md
          
          # Add contributors section
          cat >> release_notes.md << EOF
          
          ## 👥 Contributors
          EOF
          
          # Get unique contributors
          echo "Thanks to all contributors to this release:" >> release_notes.md
          echo "" >> release_notes.md
          git log ${PREVIOUS_TAG}..HEAD --pretty=format:"@%an" | sort -u | sed 's/^/* /' >> release_notes.md
          echo "" >> release_notes.md
          echo "" >> release_notes.md
          
          # Add full changelog
          cat >> release_notes.md << EOF
          
          ## 📋 Full Changelog
          
          <details>
          <summary>Click to expand</summary>
          
          \`\`\`
          EOF
          
          # Add condensed commit list
          git log ${PREVIOUS_TAG}..HEAD --pretty=format:"%h - %s (%an, %ar)" >> release_notes.md
          
          cat >> release_notes.md << EOF
          \`\`\`
          
          </details>
          
          ## 🔗 Compare
          
          **Full Changelog**: [$PREVIOUS_TAG...$VERSION](${{ github.server_url }}/${{ github.repository }}/compare/${PREVIOUS_TAG}...${VERSION})
          
          ---
          *This release was automatically generated by GitHub Actions*
          EOF
          
          # Output the release notes for debugging
          echo "Release notes generated:"
          cat release_notes.md
      
      - name: Create GitHub Release
        id: create-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Using GitHub CLI which is pre-installed in GitHub Actions
          gh release create "${{ needs.prepare-release.outputs.version }}" \
            --title "Release ${{ needs.prepare-release.outputs.version }}" \
            --notes-file release_notes.md \
            --target ${{ github.sha }}
          
          # Get the release URL
          RELEASE_URL=$(gh release view "${{ needs.prepare-release.outputs.version }}" --json url -q .url)
          echo "html_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          
          echo "✅ Release created: $RELEASE_URL"
      
      - name: Print release summary
        run: |
          echo "🚀 Release Summary"
          echo "=================="
          echo "Release Version: ${{ needs.prepare-release.outputs.version }}"
          echo "Apps to Build: ${{ needs.prepare-release.outputs.apps }}"
          echo "Release URL: ${{ steps.create-release.outputs.html_url }}"
          
      - name: Create job summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # 🚀 Release Build Summary
          
          ## ✅ Release Created Successfully!
          
          ### Version Information
          - **Release Version**: \`${{ needs.prepare-release.outputs.version }}\`
          - **Version Mode**: ${{ github.event.inputs.version_mode }}
          - **GitHub Release**: [View Release](${{ steps.create-release.outputs.html_url }})
          
          ### Apps to Build
          - **Selection Mode**: ${{ github.event.inputs.app_selection }}
          EOF
          
          if [ "${{ github.event.inputs.app_selection }}" == "specific" ]; then
            echo "- **Selected App**: ${{ github.event.inputs.specific_app }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Apps List:" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          echo '${{ needs.prepare-release.outputs.apps }}' | jq '.' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🎯 Release Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: \`${{ needs.prepare-release.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Release URL**: ${{ steps.create-release.outputs.html_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Workflow triggered by: @${{ github.actor }} • Run #${{ github.run_number }}*" >> $GITHUB_STEP_SUMMARY