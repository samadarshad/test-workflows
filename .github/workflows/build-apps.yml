# Build Apps Workflow
# 
# This workflow builds mobile apps using Bitrise for multiple apps, platforms, and environments.
# 
# Required Secrets:
# - BITRISE_ACCESS_TOKEN: Bitrise API access token
# 
# Required Repository Variables:
# - BITRISE_PROJECT_SLUG: Bitrise project identifier
# - SLACK_WEBHOOK_URL: Slack webhook for notifications (optional)
#
# Required Repository Variables (for app-specific connected app IDs):
# - BITRISE_CONNECTED_APP_ID_EV_ENERGY: Connected app ID for ev.energy Android builds
# - BITRISE_CONNECTED_APP_ID_NGMA: Connected app ID for NGMA Android builds
# - BITRISE_CONNECTED_APP_ID_NGNY: Connected app ID for NGNY Android builds
# - BITRISE_CONNECTED_APP_ID_SVCE: Connected app ID for SVCE Android builds
# - BITRISE_CONNECTED_APP_ID_MCE: Connected app ID for MCE Android builds
# - BITRISE_CONNECTED_APP_ID_ANWB: Connected app ID for ANWB Android builds
#
# Set these at: Settings > Secrets and variables > Actions > Variables tab
# Each app requires its own specific connected app ID variable

name: Build Apps

run-name: "Build Apps: ${{ github.ref_name }} - ${{ github.event.inputs.app_selection }}"

on:
  workflow_dispatch:
    inputs:
      app_selection:
        description: 'Apps to build'
        required: true
        type: choice
        options:
          - All Apps
          - ev.energy
          - NGMA
          - NGNY
          - SVCE
          - MCE
          - ANWB
        default: All Apps

jobs:
  determine-build-parameters:
    runs-on: ubuntu-latest
    outputs:
      branch_name: ${{ steps.determine-branch.outputs.branch_name }}
      apps: ${{ steps.determine-apps.outputs.apps }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine branch to build
        id: determine-branch
        run: |
          CURRENT_BRANCH="${{ github.ref_name }}"
          
          echo "Using branch: $CURRENT_BRANCH"
          echo "branch_name=$CURRENT_BRANCH" >> $GITHUB_OUTPUT
          
          # Display branch banner
          echo ""
          echo "╔════════════════════════════════════════╗"
          echo "║     BUILD BRANCH: $CURRENT_BRANCH           "
          echo "╚════════════════════════════════════════╝"
          echo ""
      
      - name: Determine apps to build
        id: determine-apps
        run: |
          if [ "${{ github.event.inputs.app_selection }}" == "All Apps" ]; then
            APPS='["ev.energy", "NGMA", "NGNY", "SVCE", "MCE", "ANWB"]'
            echo "Building all apps"
          else
            APPS='["${{ github.event.inputs.app_selection }}"]'
            echo "Building specific app: ${{ github.event.inputs.app_selection }}"
          fi
          
          echo "apps=$APPS" >> $GITHUB_OUTPUT
      
      - name: 📋 Build Summary
        run: |
          VERSION="${{ steps.determine-branch.outputs.branch_name }}"
          APPS='${{ steps.determine-apps.outputs.apps }}'
          
          echo ""
          echo "╔══════════════════════════════════════════════════════════════╗"
          echo "║                        � BUILD SUMMARY                      ║"
          echo "╚══════════════════════════════════════════════════════════════╝"
          echo ""
          echo "🏷️  RELEASE VERSION: $VERSION"
          echo "🎯 BUILD STRATEGY:   ${{ github.event.inputs.version != '' && 'Manual Version' || 'Latest Release' }}"
          echo "📱 APP SELECTION:    ${{ github.event.inputs.app_selection }}"
          echo "👤 TRIGGERED BY:     @${{ github.actor }}"
          echo "🕐 STARTED AT:       $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""
          echo "📋 APPS TO BUILD:"
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "   • $app"
          done
          echo ""
          
          # Calculate total builds
          APP_COUNT=$(echo "$APPS" | jq -r '. | length')
          TOTAL_BUILDS=$((APP_COUNT * 4))
          
          echo "📊 BUILD DETAILS:"
          echo "   • Total Apps: $APP_COUNT"
          echo "   • Platforms: Android & iOS"
          echo "   • Environments: Staging & Production"
          echo "   • Total Builds: $TOTAL_BUILDS"
          echo ""
          echo "🔗 REFERENCE LINKS:"
          echo "   • Branch: https://github.com/${{ github.repository }}/tree/$VERSION"
          echo "   • Workflow: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "   • Repository: https://github.com/${{ github.repository }}"
          echo ""
          echo "═══════════════════════════════════════════════════════════════"
          echo "🚀 Starting Bitrise builds for $TOTAL_BUILDS workflows..."
          echo "═══════════════════════════════════════════════════════════════"
          echo ""
          
          # Create GitHub Step Summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # 🚀 Build Summary
          
          ## 📋 Build Configuration
          
          | Field | Value |
          |-------|-------|
          | **Build Branch** | [🌿 $VERSION](https://github.com/${{ github.repository }}/tree/$VERSION) |
          | **App Selection** | ${{ github.event.inputs.app_selection }} |
          | **Triggered By** | @${{ github.actor }} |
          | **Started At** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |
          
          ## 📱 Apps to Build
          
          EOF
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "- **$app** (Android + iOS, Staging + Production)" >> $GITHUB_STEP_SUMMARY
          done
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          
          ## 📊 Build Overview
          
          - **Total Apps**: $APP_COUNT
          - **Platforms**: Android & iOS
          - **Environments**: Staging & Production  
          - **Total Builds**: $TOTAL_BUILDS
          
          ## 🔗 Links
          
          - [🌿 Branch $VERSION](https://github.com/${{ github.repository }}/tree/$VERSION)
          - [🔄 Workflow Run #${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [📂 Repository](https://github.com/${{ github.repository }})
          - [🏗️ Bitrise Dashboard](https://app.bitrise.io/app/${{ vars.BITRISE_PROJECT_SLUG }})
          
          ---
          
          **Next**: Triggering $TOTAL_BUILDS Bitrise builds across all apps, platforms, and environments...
          
          ---
          EOF
  
  slack-trigger-notification:
    needs: determine-build-parameters
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Send initial Slack notification
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "⚠️ SLACK_WEBHOOK_URL not configured - skipping Slack notification"
            exit 0
          fi
          
          VERSION="${{ needs.determine-build-parameters.outputs.branch_name }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "📤 Sending initial Slack notification for build trigger..."
          
          # Build the apps list for the message
          APPS_LIST=""
          echo "$APPS" | jq -r '.[]' | while read app; do
            APPS_LIST="${APPS_LIST}• $app (Android + iOS, Staging + Production)\n"
          done
          
          # Calculate total builds
          APP_COUNT=$(echo "$APPS" | jq -r '. | length')
          TOTAL_BUILDS=$((APP_COUNT * 4))
          
          # Determine app description for concise message
          if [ "${{ github.event.inputs.app_selection }}" == "All Apps" ]; then
            APP_DESCRIPTION="All apps"
          else
            APP_DESCRIPTION="${{ github.event.inputs.app_selection }}"
          fi
          
          # Create minimal one-line message
          MESSAGE_TEXT="🚀 Building <${{ github.server_url }}/${{ github.repository }}/tree/$VERSION|$VERSION> → $APP_DESCRIPTION → <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Run #${{ github.run_number }}>"
          
          # Escape for JSON
          MESSAGE_CONTENT=$(echo "$MESSAGE_TEXT" | jq -Rs .)
          
          # Create JSON payload
          PAYLOAD=$(cat << EOF
          {
            "text": "🚀 Build Workflow Started - Release $VERSION",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": $MESSAGE_CONTENT
                }
              }
            ]
          }
          EOF
          )
          
          echo "Payload preview:"
          echo "$PAYLOAD" | jq .
          
          # Send to Slack
          RESPONSE=$(curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL")
          
          if [ "$RESPONSE" = "ok" ]; then
            echo "✅ Initial Slack notification sent successfully!"
          else
            echo "❌ Failed to send initial Slack notification. Response: $RESPONSE"
            # Don't fail the workflow for notification issues
            echo "⚠️ Continuing with build process despite notification failure"
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
  
  build-apps:
    needs: [determine-build-parameters, slack-trigger-notification]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.determine-build-parameters.outputs.apps) }}
        platform: [android, ios]
        environment: [staging, production]
    
    steps:
      - name: Prepare build configuration
        id: build-config
        run: |
          # Convert app name to lowercase and remove dots for workflow name
          APP_NAME="${{ matrix.app }}"
          APP_NAME_LOWER=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          APP_NAME_CLEAN=$(echo "$APP_NAME_LOWER" | tr -d '.')
          
          # Construct workflow name
          WORKFLOW_NAME="${APP_NAME_CLEAN}-${{ matrix.platform }}-${{ matrix.environment }}"
          
          # Release branch name
          BRANCH_NAME="${{ needs.determine-build-parameters.outputs.branch_name }}"
          
          echo "app_name_clean=$APP_NAME_CLEAN" >> $GITHUB_OUTPUT
          echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          echo "📱 Build Configuration:"
          echo "  App: ${{ matrix.app }}"
          echo "  Platform: ${{ matrix.platform }}"
          echo "  Environment: ${{ matrix.environment }}"
          echo "  Workflow: $WORKFLOW_NAME"
          echo "  Branch: $BRANCH_NAME"
          echo "  Branch: ${{ needs.determine-build-parameters.outputs.branch_name }}"
      
      - name: Trigger Bitrise build
        id: trigger-bitrise
        env:
          BITRISE_APP_ID: ${{ vars.BITRISE_PROJECT_SLUG }}
          BITRISE_ACCESS_TOKEN: ${{ secrets.BITRISE_ACCESS_TOKEN }}
        run: |
          WORKFLOW_NAME="${{ steps.build-config.outputs.workflow_name }}"
          BRANCH_NAME="${{ steps.build-config.outputs.branch_name }}"
          VERSION="${{ needs.determine-build-parameters.outputs.branch_name }}"
          
          echo "🚀 Triggering Bitrise build for $WORKFLOW_NAME"
          
          # Trigger Bitrise build using personal access token
          RESPONSE=$(curl -X POST "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds" \
            -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{
              \"hook_info\": {
                \"type\": \"bitrise\"
              },
              \"build_params\": {
                \"branch\": \"${BRANCH_NAME}\",
                \"workflow_id\": \"${WORKFLOW_NAME}\",
                \"environments\": [
                  {
                    \"mapped_to\": \"BUILD_BRANCH\",
                    \"value\": \"${BRANCH_NAME}\",
                    \"is_expand\": true
                  },
                  {
                    \"mapped_to\": \"TRIGGERED_BY\",
                    \"value\": \"GitHub Actions - ${{ github.actor }}\",
                    \"is_expand\": true
                  }
                ],
                \"commit_message\": \"Build from branch ${BRANCH_NAME} - ${{ matrix.app }} (${{ matrix.platform }}/${{ matrix.environment }})\"
              }
            }")
          
          # Debug: Show full response structure
          echo "🔍 Full Bitrise API Response:"
          echo "$RESPONSE" | jq .
          
          # Extract build URL, status, build number, and public install page URL
          BUILD_URL=$(echo "$RESPONSE" | jq -r '.build_url // empty')
          BUILD_SLUG=$(echo "$RESPONSE" | jq -r '.build_slug // empty')
          BUILD_NUMBER=$(echo "$RESPONSE" | jq -r '.build_number // empty')
          PUBLIC_INSTALL_PAGE_URL=$(echo "$RESPONSE" | jq -r '.public_install_page_url // empty')
          STATUS=$(echo "$RESPONSE" | jq -r '.status // empty')
          
          if [ -z "$BUILD_URL" ] || [ "$STATUS" == "error" ]; then
            echo "❌ Failed to trigger Bitrise build"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          echo "✅ Bitrise build triggered successfully"
          echo "Build URL: $BUILD_URL"
          echo "Build Slug: $BUILD_SLUG"
          echo "Build Number: $BUILD_NUMBER"
          echo "Public Install Page: $PUBLIC_INSTALL_PAGE_URL"
          
          # Check available fields for install page
          echo "🔍 Checking for install page related fields:"
          echo "$RESPONSE" | jq 'keys[]' | grep -i install || echo "No install-related keys found"
          
          echo "build_url=$BUILD_URL" >> $GITHUB_OUTPUT
          echo "build_slug=$BUILD_SLUG" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "public_install_page_url=$PUBLIC_INSTALL_PAGE_URL" >> $GITHUB_OUTPUT
      
      - name: Save build slug for cancellation
        run: |
          BUILD_SLUG="${{ steps.trigger-bitrise.outputs.build_slug }}"
          
          # Create build slug info for cancellation purposes
          BUILD_INFO=$(cat << EOF
          {
            "app": "${{ matrix.app }}",
            "platform": "${{ matrix.platform }}",
            "environment": "${{ matrix.environment }}",
            "build_slug": "$BUILD_SLUG",
            "build_url": "${{ steps.trigger-bitrise.outputs.build_url }}",
            "workflow_name": "${{ steps.build-config.outputs.workflow_name }}",
            "triggered_at": "$(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          }
          EOF
          )
          
          # Save to cancellation artifacts directory
          mkdir -p build-slugs
          echo "$BUILD_INFO" > "build-slugs/${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}.json"
      
      - name: Upload build slug for cancellation
        uses: actions/upload-artifact@v4
        with:
          name: build-slug-${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}
          path: build-slugs/
          retention-days: 1
      
      - name: Wait for Bitrise build completion
        id: wait-for-completion
        uses: eball/poll-check-endpoint@v0.1.0
        with:
          url: 'https://api.bitrise.io/v0.1/apps/${{ vars.BITRISE_PROJECT_SLUG }}/builds/${{ steps.trigger-bitrise.outputs.build_slug }}'
          method: GET
          customHeaders: '{"Authorization": "token ${{ secrets.BITRISE_ACCESS_TOKEN }}"}'
          expectStatus: 200
          expectBodyRegex: '"status_text":\s*"(success)"'
          failedBodyRegex: '"status_text":\s*"(error|aborted)"'
          timeout: 3600000  # 1 hour in milliseconds
          interval: 30000   # 30 seconds in milliseconds
        continue-on-error: true
      
      - name: Extract build completion status
        id: extract-status
        run: |
          # The poll action succeeded if the build completed successfully
          # Failed if it matched failedBodyRegex (error/aborted)
          # Timed out if it exceeded the timeout
          
          echo "⏳ Extracting final build status..."
          
          # Get the final build status from Bitrise API
          BUILD_SLUG="${{ steps.trigger-bitrise.outputs.build_slug }}"
          
          STATUS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.BITRISE_ACCESS_TOKEN }}" \
            "https://api.bitrise.io/v0.1/apps/${{ vars.BITRISE_PROJECT_SLUG }}/builds/${BUILD_SLUG}")
          
          if echo "$STATUS_RESPONSE" | jq empty 2>/dev/null; then
            BUILD_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.data.status_text // "unknown"')
            FINISHED_AT=$(echo "$STATUS_RESPONSE" | jq -r '.data.finished_at // null')
            
            echo "Final Build Status: $BUILD_STATUS"
            echo "Finished At: $FINISHED_AT"
            
            # Debug: Show full build completion response (only for Android)
            if [ "${{ matrix.platform }}" = "android" ]; then
              echo "🔍 Full build completion response:"
              echo "$STATUS_RESPONSE" | jq .data
            fi
            
            # Set outputs based on the polling result and final status
            if [ "${{ steps.wait-for-completion.outcome }}" = "success" ]; then
              echo "✅ Build completed successfully"
              echo "final_status=success" >> $GITHUB_OUTPUT
              echo "build_completed=true" >> $GITHUB_OUTPUT
              echo "build_failed=false" >> $GITHUB_OUTPUT
            elif [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ]; then
              echo "❌ Build failed with status: $BUILD_STATUS"
              echo "final_status=$BUILD_STATUS" >> $GITHUB_OUTPUT
              echo "build_completed=true" >> $GITHUB_OUTPUT
              echo "build_failed=true" >> $GITHUB_OUTPUT
            elif [ "${{ steps.wait-for-completion.outcome }}" = "failure" ]; then
              echo "⏱️ Build polling timed out or failed"
              echo "final_status=timeout" >> $GITHUB_OUTPUT
              echo "build_completed=false" >> $GITHUB_OUTPUT
              echo "build_failed=false" >> $GITHUB_OUTPUT
            else
              echo "❓ Unknown polling outcome: ${{ steps.wait-for-completion.outcome }}"
              echo "final_status=unknown" >> $GITHUB_OUTPUT
              echo "build_completed=false" >> $GITHUB_OUTPUT
              echo "build_failed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Failed to get final build status from Bitrise API"
            echo "final_status=api_error" >> $GITHUB_OUTPUT
            echo "build_completed=false" >> $GITHUB_OUTPUT
            echo "build_failed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Resolve connected app ID for Android
        id: resolve-connected-app-id
        if: matrix.platform == 'android'
        run: |
          APP_NAME="${{ matrix.app }}"
          
          # Convert app name to a valid variable name format (uppercase, replace dots with underscores)
          APP_VAR_NAME=$(echo "$APP_NAME" | tr '[:lower:]' '[:upper:]' | tr '.' '_')
          
          echo "🔍 Resolving connected app ID for app: $APP_NAME"
          echo "Looking for variable: BITRISE_CONNECTED_APP_ID_${APP_VAR_NAME}"
          
          # Get app-specific connected app ID from variables
          case "$APP_VAR_NAME" in
            "EV_ENERGY")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_EV_ENERGY }}"
              ;;
            "NGMA")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_NGMA }}"
              ;;
            "NGNY")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_NGNY }}"
              ;;
            "SVCE")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_SVCE }}"
              ;;
            "MCE")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_MCE }}"
              ;;
            "ANWB")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_ANWB }}"
              ;;
            *)
              echo "⚠️ Unknown app: $APP_NAME - no connected app ID configured"
              CONNECTED_APP_ID=""
              ;;
          esac
          
          if [ -n "$CONNECTED_APP_ID" ]; then
            echo "✅ Using connected app ID: ${CONNECTED_APP_ID:0:8}... (for $APP_NAME)"
            echo "connected_app_id=$CONNECTED_APP_ID" >> $GITHUB_OUTPUT
          else
            echo "❌ No connected app ID found for $APP_NAME"
            echo "💡 Set BITRISE_CONNECTED_APP_ID_${APP_VAR_NAME} repository variable"
            echo "connected_app_id=" >> $GITHUB_OUTPUT
          fi
      
      - name: Get public install page URL
        id: get-install-url
        if: matrix.platform == 'android' && steps.extract-status.outputs.build_completed == 'true' && steps.extract-status.outputs.final_status == 'success'
        run: |
          echo "🤖 Android build successful - using Release Management API to get public install page URL..."
          
          # Poll for install page URL using Release Management API
          INSTALL_PAGE_WAIT_TIME=180  # 3 minutes max wait for install page
          INSTALL_PAGE_POLL_INTERVAL=15  # Check every 15 seconds
          install_page_elapsed=0
          
          # Extract build number for Release Management API search
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          
          echo "🔍 Searching Release Management API with build number: $BUILD_NUMBER"
          
          FINAL_PUBLIC_INSTALL_URL=""
          
          while [ $install_page_elapsed -lt $INSTALL_PAGE_WAIT_TIME ]; do
            echo "🔍 Checking Release Management API for install page URL (elapsed: ${install_page_elapsed}s)..."
            
            # Use Release Management API to find installable artifacts
            # Use the app-specific connected app ID resolved earlier
            CONNECTED_APP_ID="${{ steps.resolve-connected-app-id.outputs.connected_app_id }}"
            
            if [ -n "$CONNECTED_APP_ID" ]; then
              # Search by build number only
              RELEASE_MGMT_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.BITRISE_ACCESS_TOKEN }}" \
                "https://api.bitrise.io/release-management/v1/connected-apps/${CONNECTED_APP_ID}/installable-artifacts?items_per_page=20&page=1&search=${BUILD_NUMBER}")
              
              echo "🔍 Release Management API response:"
              echo "$RELEASE_MGMT_RESPONSE" | jq . || echo "Invalid JSON response"
              
              if echo "$RELEASE_MGMT_RESPONSE" | jq empty 2>/dev/null; then
                # Check if we got any items
                ITEM_COUNT=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r '.count // 0')
                echo "Found $ITEM_COUNT installable artifact(s)"
                
                if [ "$ITEM_COUNT" -gt 0 ]; then
                  # Find the exact artifact matching the build number and platform
                  FINAL_PUBLIC_INSTALL_URL=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg build_num "$BUILD_NUMBER" \
                    '.items[] | select(.build_number == $build_num) | select(.platform == "android") | select(.public_install_page_url != null) | .public_install_page_url' | head -1)
                  
                  # Check if we found a valid URL
                  if [ -n "$FINAL_PUBLIC_INSTALL_URL" ] && [ "$FINAL_PUBLIC_INSTALL_URL" != "empty" ] && [ "$FINAL_PUBLIC_INSTALL_URL" != "null" ]; then
                    echo "✅ Found install page URL from Release Management API: $FINAL_PUBLIC_INSTALL_URL"
                    
                    # Show which artifact we matched
                    MATCHED_ARTIFACT=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg url "$FINAL_PUBLIC_INSTALL_URL" \
                      '.items[] | select(.public_install_page_url == $url) | "\(.app_name) - \(.workflow) - \(.filename) - Build #\(.build_number)"')
                    echo "📱 Matched artifact: $MATCHED_ARTIFACT"
                    break
                  else
                    echo "⚠️ No public install page URL found for Android artifact with build number $BUILD_NUMBER"
                  fi
                else
                  echo "⚠️ No installable artifacts found for build $BUILD_NUMBER"
                fi
              fi
            else
              echo "⚠️ Connected app ID not available - Release Management API unavailable"
              echo "💡 Set BITRISE_CONNECTED_APP_ID_${APP_VAR_NAME} repository variable"
            fi
            
            echo "⏳ Install page URL not ready yet, waiting ${INSTALL_PAGE_POLL_INTERVAL}s..."
            sleep $INSTALL_PAGE_POLL_INTERVAL
            install_page_elapsed=$((install_page_elapsed + INSTALL_PAGE_POLL_INTERVAL))
          done
          
          # Check if we timed out waiting for install page
          if [ $install_page_elapsed -ge $INSTALL_PAGE_WAIT_TIME ] && ([ -z "$FINAL_PUBLIC_INSTALL_URL" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "empty" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "null" ]); then
            echo "⚠️ Timed out waiting for install page URL after ${INSTALL_PAGE_WAIT_TIME}s"
            echo "🎯 Note: Install page may still become available later - check Bitrise dashboard"
            echo "💡 Tip: Ensure correct connected app ID is configured for ${{ matrix.app }}"
            FINAL_PUBLIC_INSTALL_URL=""
          fi
          
          echo "Final Public Install Page: $FINAL_PUBLIC_INSTALL_URL"
          echo "install_url=$FINAL_PUBLIC_INSTALL_URL" >> $GITHUB_OUTPUT
      
      - name: Create build summary entry
        if: always()
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.extract-status.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.extract-status.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.get-install-url.outputs.install_url }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ### ${{ matrix.app }} - ${{ matrix.platform }}/${{ matrix.environment }}
          - **Workflow**: \`${{ steps.build-config.outputs.workflow_name }}\`
          - **Branch**: \`${{ steps.build-config.outputs.branch_name }}\`
          EOF
          
          # Check if build was even triggered
          if [ -z "$BUILD_NUMBER" ]; then
            echo "- **Build Number**: _Build not triggered_" >> $GITHUB_STEP_SUMMARY
            echo "- **Install Page**: _No build available_" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ❌ **FAILED** - Build trigger failed" >> $GITHUB_STEP_SUMMARY
            echo "- **Bitrise Build**: _No build URL available_" >> $GITHUB_STEP_SUMMARY
          elif [ "$BUILD_COMPLETED" = "true" ]; then
            case "$FINAL_STATUS" in
              "success")
                if [ "${{ matrix.platform }}" = "android" ]; then
                  # Android builds should have install pages
                  if [ -n "$FINAL_INSTALL_URL" ] && [ "$FINAL_INSTALL_URL" != "null" ] && [ "$FINAL_INSTALL_URL" != "empty" ]; then
                    echo "- **Build Number**: [#$BUILD_NUMBER]($FINAL_INSTALL_URL) 📱" >> $GITHUB_STEP_SUMMARY
                    echo "- **Install Page**: [Download APK]($FINAL_INSTALL_URL) 🤖" >> $GITHUB_STEP_SUMMARY
                    echo "- **Status**: ✅ **SUCCESS** - Ready to install!" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                    echo "- **Install Page**: _No install page available_" >> $GITHUB_STEP_SUMMARY
                    echo "- **Status**: ✅ **SUCCESS** - Check Bitrise for APK" >> $GITHUB_STEP_SUMMARY
                  fi
                else
                  # iOS builds don't need install pages
                  echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                  echo "- **Install Page**: _iOS build (TestFlight/App Store)_ 🍎" >> $GITHUB_STEP_SUMMARY
                  echo "- **Status**: ✅ **SUCCESS** - Check Bitrise for artifacts" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              "error")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build failed - no install page available_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ❌ **FAILED** - [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})" >> $GITHUB_STEP_SUMMARY
                ;;
              "aborted")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build was aborted_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ⚠️ **ABORTED** - [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})" >> $GITHUB_STEP_SUMMARY
                ;;
              "timeout")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build still in progress - check Bitrise_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ⏱️ **TIMEOUT** - Build taking longer than expected" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Status: $FINAL_STATUS_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ❓ **$FINAL_STATUS**" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            # Build was triggered but didn't complete within timeout or failed during monitoring
            if [ -n "$BUILD_NUMBER" ]; then
              echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
              if [ "$BUILD_COMPLETED" = "false" ]; then
                echo "- **Install Page**: _Build did not complete within timeout_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ⏱️ **TIMEOUT** - Build taking longer than expected" >> $GITHUB_STEP_SUMMARY
              else
                echo "- **Install Page**: _Build monitoring failed_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ❓ **UNKNOWN** - Check Bitrise for current status" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "- **Build Number**: _Unknown_" >> $GITHUB_STEP_SUMMARY
              echo "- **Install Page**: _Build status unknown_" >> $GITHUB_STEP_SUMMARY
              echo "- **Status**: ❓ **UNKNOWN** - Build monitoring may have failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Add Bitrise build link if available
          if [ -n "${{ steps.trigger-bitrise.outputs.build_url }}" ]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          - **Bitrise Build**: [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})
          
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY <<EOF
          - **Bitrise Build**: _No build URL available_
          
          EOF
          fi
      
      - name: Save build results for Slack notification
        if: always()
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.extract-status.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.extract-status.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.get-install-url.outputs.install_url }}"
          
          # Handle cases where build wasn't triggered or completed
          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER="N/A"
            FINAL_STATUS="trigger_failed"
            BUILD_COMPLETED="false"
          elif [ -z "$FINAL_STATUS" ]; then
            FINAL_STATUS="unknown"
          fi
          
          # Create build result JSON
          BUILD_RESULT=$(cat << EOF
          {
            "app": "${{ matrix.app }}",
            "platform": "${{ matrix.platform }}",
            "environment": "${{ matrix.environment }}",
            "build_number": "$BUILD_NUMBER",
            "status": "$FINAL_STATUS",
            "completed": "$BUILD_COMPLETED",
            "install_url": "$FINAL_INSTALL_URL",
            "bitrise_url": "${{ steps.trigger-bitrise.outputs.build_url }}"
          }
          EOF
          )
          
          # Save to artifacts
          mkdir -p build-results
          echo "$BUILD_RESULT" > "build-results/${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}.json"
      
      - name: Upload build results
        uses: actions/upload-artifact@v4
        with:
          name: build-result-${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}
          path: build-results/
          retention-days: 1
      
      - name: Send immediate failure notification
        if: steps.extract-status.outputs.build_failed == 'true'
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            echo "🚨 Sending immediate failure notification..."
            
            VERSION="${{ needs.determine-build-parameters.outputs.branch_name }}"
            FINAL_STATUS="${{ steps.extract-status.outputs.final_status }}"
            BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
            BITRISE_URL="${{ steps.trigger-bitrise.outputs.build_url }}"
            
            # Create concise failure message similar to initiation/cancellation messages
            MESSAGE_TEXT="🚨 Failed ($FINAL_STATUS) <${{ github.server_url }}/${{ github.repository }}/tree/$VERSION|$VERSION> → ${{ matrix.app }} (${{ matrix.platform }}/${{ matrix.environment }}) → <$BITRISE_URL|Build #$BUILD_NUMBER> → <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Run #${{ github.run_number }}>"
            
            # Escape for JSON
            MESSAGE_CONTENT=$(echo "$MESSAGE_TEXT" | jq -Rs .)
            
            # Create base payload
            TEXT_FIELD="🚨 Build Failed - ${{ matrix.app }} ${{ matrix.platform }}/${{ matrix.environment }}"
            
            PAYLOAD="{\"text\":\"$TEXT_FIELD\",\"blocks\":[{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":$MESSAGE_CONTENT}}]}"
            
            curl -X POST -H 'Content-type: application/json' \
              --data "$PAYLOAD" \
              "$SLACK_WEBHOOK_URL" && echo "✅ Failure notification sent!" || echo "⚠️ Failed to send notification"
          else
            echo "⚠️ SLACK_WEBHOOK_URL not configured - skipping failure notification"
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
        continue-on-error: true
      
      - name: Report build status
        if: steps.extract-status.outputs.build_failed == 'true'
        run: |
          echo "❌ Build failed with status: ${{ steps.extract-status.outputs.final_status }}"
          echo "🔗 Build details: ${{ steps.trigger-bitrise.outputs.build_url }}"
          echo "💡 This job will fail so you can use 'Re-run failed jobs' to retry just the failed builds"
          exit 1
  
  collect-build-status:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Create job summary
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.branch_name }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # 🚀 Bitrise Build Summary
          
          ## 📋 Build Information
          
          | Field | Value |
          |-------|-------|
          | **Build Branch** | [🌿 $VERSION](https://github.com/${{ github.repository }}/tree/$VERSION) |
          | **App Selection** | ${{ github.event.inputs.app_selection }} |
          | **Triggered by** | @${{ github.actor }} |
          | **Workflow Run** | #${{ github.run_number }} |
          
          ## 📦 Bitrise Workflows Triggered
          
          | App | Platform | Environment | Workflow | Build # | Status | Bitrise Link |
          |-----|----------|-------------|----------|---------|--------|-----------| 
          EOF
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            APP_LOWER=$(echo "$app" | tr '[:upper:]' '[:lower:]' | tr -d '.')
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                
                if [ -f "$BUILD_FILE" ]; then
                  BUILD_DATA=$(cat "$BUILD_FILE")
                  BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
                  INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
                  STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
                  COMPLETED=$(echo "$BUILD_DATA" | jq -r '.completed')
                  BITRISE_URL=$(echo "$BUILD_DATA" | jq -r '.bitrise_url // empty')
                  
                  # Format build number with hyperlink if available (Android only)
                  if [ "$platform" = "android" ] && [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                    BUILD_DISPLAY="[#$BUILD_NUM]($INSTALL_URL)"
                  else
                    BUILD_DISPLAY="\`#$BUILD_NUM\`"
                  fi
                  
                  # Format status
                  case "$STATUS" in
                    "success") STATUS_DISPLAY="✅ SUCCESS" ;;
                    "error") STATUS_DISPLAY="❌ FAILED" ;;
                    "aborted") STATUS_DISPLAY="⚠️ ABORTED" ;;
                    "timeout") STATUS_DISPLAY="⏱️ TIMEOUT" ;;
                    *) STATUS_DISPLAY="❓ $STATUS" ;;
                  esac
                  
                  # Format Bitrise link
                  if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                    BITRISE_LINK="[🔗 View Build]($BITRISE_URL)"
                  else
                    BITRISE_LINK="_No link available_"
                  fi
                  
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | $BUILD_DISPLAY | $STATUS_DISPLAY | $BITRISE_LINK |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | _No data_ | ❓ Unknown | _No build_ |" >> $GITHUB_STEP_SUMMARY
                fi
              done
            done
          done
          
          # Calculate total builds and overall status
          TOTAL_APPS=$(echo "$APPS" | jq -r '. | length')
          TOTAL_BUILDS=$((TOTAL_APPS * 4))
          
          # Count build results by status
          SUCCESS_COUNT=0
          FAILED_COUNT=0
          ABORTED_COUNT=0
          TIMEOUT_COUNT=0
          UNKNOWN_COUNT=0
          
          for app in $(echo "$APPS" | jq -r '.[]'); do
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                if [ -f "$BUILD_FILE" ]; then
                  STATUS=$(cat "$BUILD_FILE" | jq -r '.status')
                  case "$STATUS" in
                    "success") SUCCESS_COUNT=$((SUCCESS_COUNT + 1)) ;;
                    "error") FAILED_COUNT=$((FAILED_COUNT + 1)) ;;
                    "aborted") ABORTED_COUNT=$((ABORTED_COUNT + 1)) ;;
                    "timeout") TIMEOUT_COUNT=$((TIMEOUT_COUNT + 1)) ;;
                    *) UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1)) ;;
                  esac
                else
                  UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1))
                fi
              done
            done
          done
          
          # Determine overall workflow status
          if [ $FAILED_COUNT -gt 0 ] || [ $ABORTED_COUNT -gt 0 ] || [ $TIMEOUT_COUNT -gt 0 ]; then
            if [ $SUCCESS_COUNT -gt 0 ]; then
              OVERALL_STATUS="⚠️ **PARTIAL SUCCESS** - Some builds failed but workflow continued"
            else
              OVERALL_STATUS="❌ **FAILED** - All builds failed"
            fi
          elif [ $SUCCESS_COUNT -eq $TOTAL_BUILDS ]; then
            OVERALL_STATUS="✅ **SUCCESS** - All builds completed successfully"
          else
            OVERALL_STATUS="🔄 **IN PROGRESS** - Some builds still processing"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          
          ## 📊 Summary
          
          - **Overall Status**: $OVERALL_STATUS
          - **Total Apps**: $TOTAL_APPS
          - **Builds per App**: 4 (2 platforms × 2 environments)
          - **Total Builds Triggered**: $TOTAL_BUILDS
          - **Successful**: $SUCCESS_COUNT
          - **Failed**: $FAILED_COUNT
          - **Aborted**: $ABORTED_COUNT
          - **Timeout**: $TIMEOUT_COUNT
          - **Unknown/Pending**: $UNKNOWN_COUNT
          
          ## 🔗 Links
          
          - [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Bitrise Dashboard](https://app.bitrise.io/app/${{ vars.BITRISE_PROJECT_SLUG }})
          
          ---
          *Builds triggered at $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF
  
  slack-notification:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always() && !cancelled()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Prepare Slack message
        id: slack-message
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.branch_name }}"
          
          echo "📱 Preparing Slack message for release $VERSION"
          
          # Initialize message with title
          cat > slack_message.txt << EOF
          📊 *Build Results for <${{ github.server_url }}/${{ github.repository }}/tree/$VERSION|$VERSION>* (<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Run #${{ github.run_number }}>)
          
          EOF
                   
          # Process build results by app
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "Processing app: $app"
            
            # Function to process build result for a platform/environment
            process_build_result() {
              local platform="$1"
              local environment="$2"
              local build_file="build-results/${app}-${platform}-${environment}.json"
              
              if [ -f "$build_file" ]; then
                BUILD_DATA=$(cat "$build_file")
                BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
                INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
                STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
                BITRISE_URL=$(echo "$BUILD_DATA" | jq -r '.bitrise_url // empty')
                
                if [ "$STATUS" = "aborted" ]; then
                  # Build was aborted - show "(aborted)" with Bitrise link
                  if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                    echo "<$BITRISE_URL|(aborted)>"
                  else
                    echo "(aborted)"
                  fi
                elif [ "$STATUS" != "success" ]; then
                  # Build failed - link to Bitrise build with failure indicator
                  if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                    echo "<$BITRISE_URL|(failed)>"
                  else
                    echo "(failed)"
                  fi
                elif [ "$platform" = "android" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                  # Android builds with install page links
                  echo "<$INSTALL_URL|$BUILD_NUM>"
                else
                  # iOS builds or Android builds without install URLs
                  echo "$BUILD_NUM"
                fi
              else
                echo "N/A"
              fi
            }
            
            # Process builds for this app
            STAGING_ANDROID=$(process_build_result "android" "staging")
            STAGING_IOS=$(process_build_result "ios" "staging")
            PROD_ANDROID=$(process_build_result "android" "production")
            PROD_IOS=$(process_build_result "ios" "production")
            
            # Append to message file
            cat >> slack_message.txt << EOF
          ○ *$app*
              ■ *Staging:* :android: $STAGING_ANDROID  :appleinc: $STAGING_IOS
              ■ *Production:* :android: $PROD_ANDROID  :appleinc: $PROD_IOS
          EOF
          
          done
          
          # Add footer
          cat >> slack_message.txt << EOF
          
          EOF
          
          echo "Final Slack message:"
          cat slack_message.txt
      
      - name: 📋 Copy Slack Message to Summary
        run: |
          # Read the Slack message and convert to markdown format
          SLACK_MESSAGE=$(cat slack_message.txt)
          
          # Convert Slack links <URL|text> to markdown [text](URL)
          MARKDOWN_MESSAGE=$(echo "$SLACK_MESSAGE" | sed -E 's/<([^|]+)\|([^>]+)>/[\2](\1)/g')
          
          # Add only the message content to GitHub Step Summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          $MARKDOWN_MESSAGE
          EOF
      
      - name: Send Slack notification
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "⚠️ SLACK_WEBHOOK_URL not configured - skipping Slack notification"
            exit 0
          fi
          
          echo "📤 Sending Slack notification..."
          
          VERSION="${{ needs.determine-build-parameters.outputs.branch_name }}"
          
          # Read the message and check size
          MESSAGE_CONTENT=$(cat slack_message.txt | jq -Rs .)
          MESSAGE_LENGTH=$(echo "$MESSAGE_CONTENT" | jq -r length)
          echo "📏 Message length: $MESSAGE_LENGTH characters"
          
          # Function to send a Slack message
          send_slack_message() {
            local content="$1"
            local title="$2"
            
            local payload=$(cat << EOF
          {
            "text": "$title",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": $content
                }
              }
            ]
          }
          EOF
          )
            
            echo "📤 Sending message part..."
            echo "$payload" | jq .
            
            local response=$(curl -X POST -H 'Content-type: application/json' \
              --data "$payload" \
              "$SLACK_WEBHOOK_URL")
            
            if [ "$response" = "ok" ]; then
              echo "✅ Message sent successfully!"
              return 0
            else
              echo "❌ Failed to send message. Response: $response"
              return 1
            fi
          }
          
          # If message is short enough, send as single message
          if [ "$MESSAGE_LENGTH" -le 2800 ]; then
            echo "� Sending complete message in single notification"
            send_slack_message "$MESSAGE_CONTENT" "🚀 Build Results for $VERSION"
          else
            echo "� Message too long ($MESSAGE_LENGTH chars) - splitting into multiple messages"
            
            # Split message by apps
            APPS='${{ needs.determine-build-parameters.outputs.apps }}'
            
            # Send header message first
            HEADER_MESSAGE="🚀 *Build Results for $VERSION*"
            HEADER_CONTENT=$(echo "$HEADER_MESSAGE" | jq -Rs .)
            send_slack_message "$HEADER_CONTENT" "🚀 Build Results for $VERSION"
            
            # Send each app as separate message
            echo "$APPS" | jq -r '.[]' | while read app; do
              echo "📤 Sending results for app: $app"
              
              # Extract app-specific results
              APP_MESSAGE=$(grep -A 3 "○ \*$app\*" slack_message.txt | head -3)
              
              if [ -n "$APP_MESSAGE" ]; then
                APP_CONTENT=$(echo "$APP_MESSAGE" | jq -Rs .)
                send_slack_message "$APP_CONTENT" "📱 $app Results"
                
                # Small delay between messages
                sleep 1
              fi
            done
            
            echo "✅ All message parts sent successfully!"
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
  
  cancel-bitrise-builds:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: cancelled()
    
    steps:
      - name: Download build slug artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-slug-*
          merge-multiple: true
          path: build-slugs/
        continue-on-error: true
      
      - name: Cancel Bitrise builds
        env:
          BITRISE_APP_ID: ${{ vars.BITRISE_PROJECT_SLUG }}
          BITRISE_ACCESS_TOKEN: ${{ secrets.BITRISE_ACCESS_TOKEN }}
        run: |
          echo "🚫 Workflow cancelled - attempting to cancel Bitrise builds..."
          
          CANCELLED_COUNT=0
          TOTAL_BUILDS=0
          
          if [ ! -d "build-slugs" ]; then
            echo "⚠️ No build slug artifacts found - builds may not have been triggered yet"
            exit 0
          fi
          
          # Process each build slug file
          for build_file in build-slugs/*.json; do
            if [ ! -f "$build_file" ]; then
              echo "⚠️ No build slug files found"
              continue
            fi
            
            TOTAL_BUILDS=$((TOTAL_BUILDS + 1))
            
            # Extract build information
            BUILD_DATA=$(cat "$build_file")
            BUILD_SLUG=$(echo "$BUILD_DATA" | jq -r '.build_slug')
            APP=$(echo "$BUILD_DATA" | jq -r '.app')
            PLATFORM=$(echo "$BUILD_DATA" | jq -r '.platform')
            ENVIRONMENT=$(echo "$BUILD_DATA" | jq -r '.environment')
            BUILD_URL=$(echo "$BUILD_DATA" | jq -r '.build_url')
            
            echo ""
            echo "📱 Processing: $APP ($PLATFORM/$ENVIRONMENT)"
            echo "🔗 Build Slug: $BUILD_SLUG"
            echo "🌐 Build URL: $BUILD_URL"
            
            # Check current build status first
            echo "🔍 Checking current build status..."
            STATUS_RESPONSE=$(curl -s -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
              "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds/${BUILD_SLUG}")
            
            if ! echo "$STATUS_RESPONSE" | jq empty 2>/dev/null; then
              echo "❌ Failed to get build status (invalid JSON response)"
              continue
            fi
            
            BUILD_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.data.status_text // "unknown"')
            FINISHED_AT=$(echo "$STATUS_RESPONSE" | jq -r '.data.finished_at // null')
            
            echo "📊 Current Status: $BUILD_STATUS"
            
            # Skip if build is already finished
            if [ "$BUILD_STATUS" = "success" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ] || [ "$FINISHED_AT" != "null" ]; then
              echo "✅ Build already finished ($BUILD_STATUS) - skipping cancellation"
              continue
            fi
            
            # Attempt to cancel the build
            echo "🚫 Attempting to cancel build..."
            CANCEL_RESPONSE=$(curl -s -X POST -w "HTTPSTATUS:%{http_code}" \
              -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
              -H "Content-Type: application/json" \
              -d '{"abort_reason": "GitHub Actions workflow was cancelled"}' \
              "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds/${BUILD_SLUG}/abort")
            
            # Extract HTTP status and response
            HTTP_STATUS=$(echo "$CANCEL_RESPONSE" | grep -o 'HTTPSTATUS:[0-9]*' | cut -d: -f2)
            CANCEL_DATA=$(echo "$CANCEL_RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
            
            echo "🌐 HTTP Status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "✅ Successfully cancelled Bitrise build for $APP ($PLATFORM/$ENVIRONMENT)"
              CANCELLED_COUNT=$((CANCELLED_COUNT + 1))
            elif [ "$HTTP_STATUS" = "400" ]; then
              echo "⚠️ Build cannot be cancelled (likely already finished or not running)"
            elif [ "$HTTP_STATUS" = "404" ]; then
              echo "❌ Build not found - may have been already cancelled or removed"
            else
              echo "❌ Failed to cancel build (HTTP $HTTP_STATUS)"
              echo "Response: $CANCEL_DATA"
            fi
          done
          
          echo ""
          echo "📊 Cancellation Summary:"
          echo "  Total builds processed: $TOTAL_BUILDS"
          echo "  Successfully cancelled: $CANCELLED_COUNT"
          echo "  Skipped (already finished): $((TOTAL_BUILDS - CANCELLED_COUNT))"
          
          if [ $CANCELLED_COUNT -gt 0 ]; then
            echo "✅ Cancelled $CANCELLED_COUNT Bitrise build(s) due to workflow cancellation"
          else
            echo "ℹ️ No running builds found to cancel"
          fi
      
      - name: Create cancellation summary
        if: always()
        run: |
          CURRENT_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # 🚫 Workflow Cancelled - Bitrise Build Cleanup
          
          ## 📋 Cancellation Information
          
          | Field | Value |
          |-------|-------|
          | **Cancelled At** | $CURRENT_TIME |
          | **Build Branch** | [🌿 ${{ needs.determine-build-parameters.outputs.branch_name }}](https://github.com/${{ github.repository }}/tree/${{ needs.determine-build-parameters.outputs.branch_name }}) |
          | **Triggered by** | @${{ github.actor }} |
          | **Workflow Run** | #${{ github.run_number }} |
          
          ## 🚫 Build Cancellation Status
          
          The workflow was cancelled and we attempted to cancel any running Bitrise builds to prevent unnecessary resource usage.
          
          **Note**: 
          - Builds that were already completed (success/error/aborted) were left as-is
          - Only running or queued builds were cancelled
          - Check the job logs above for detailed cancellation results
          
          ## 🔗 Links
          
          - [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Bitrise Dashboard](https://app.bitrise.io/app/${{ vars.BITRISE_PROJECT_SLUG }})
          
          ---
          *Cancellation processed at $CURRENT_TIME*
          EOF
      
      - name: Send cancellation Slack notification
        if: always()
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            echo "📤 Sending workflow cancellation notification to Slack..."
            
            VERSION="${{ needs.determine-build-parameters.outputs.branch_name }}"
            APPS='${{ needs.determine-build-parameters.outputs.apps }}'
            
            # Determine app description for concise message
            if [ "${{ github.event.inputs.app_selection }}" == "All Apps" ]; then
              APP_DESCRIPTION="All apps"
            else
              APP_DESCRIPTION="${{ github.event.inputs.app_selection }}"
            fi
            
            # Create minimal cancellation message
            MESSAGE_TEXT=":no_entry_sign: Cancelled <${{ github.server_url }}/${{ github.repository }}/tree/$VERSION|$VERSION> → $APP_DESCRIPTION → <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Run #${{ github.run_number }}>"
            
            # Escape for JSON
            MESSAGE_CONTENT=$(echo "$MESSAGE_TEXT" | jq -Rs .)
            
            # Create base payload
            TEXT_FIELD=":no_entry_sign: Build Workflow Cancelled - Release $VERSION"
            
            PAYLOAD="{\"text\":\"$TEXT_FIELD\",\"blocks\":[{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":$MESSAGE_CONTENT}}]}"
            
            curl -X POST -H 'Content-type: application/json' \
              --data "$PAYLOAD" \
              "$SLACK_WEBHOOK_URL" && echo "✅ Cancellation notification sent!" || echo "⚠️ Failed to send notification"
          else
            echo "⚠️ SLACK_WEBHOOK_URL not configured - skipping cancellation notification"
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
        continue-on-error: true
