name: Build Apps

run-name: "Build Apps: ${{ github.event.inputs.version_source == 'latest' && 'Latest Release' || github.event.inputs.manual_version }} - ${{ github.event.inputs.app_selection == 'all' && 'All apps' || github.event.inputs.specific_app }}"

on:
  workflow_dispatch:
    inputs:
      version_source:
        description: 'Version source'
        required: true
        type: choice
        options:
          - latest
          - manual
        default: latest
      
      manual_version:
        description: 'Manual version (e.g., v3.28.0) - only used if version_source is "manual"'
        required: false
        type: string
      
      app_selection:
        description: 'Apps to build'
        required: true
        type: choice
        options:
          - all
          - specific
        default: all
      
      specific_app:
        description: 'Specific app name (only used if app_selection is "specific")'
        required: false
        type: choice
        options:
          - ev.energy
          - NGMA
          - NGNY
          - SVCE
          - MCE
          - ANWB
        default: ev.energy

jobs:
  determine-build-parameters:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.determine-version.outputs.version }}
      apps: ${{ steps.determine-apps.outputs.apps }}
      release_exists: ${{ steps.check-release.outputs.exists }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine version to build
        id: determine-version
        run: |
          if [ "${{ github.event.inputs.version_source }}" == "latest" ]; then
            # Get the latest release tag
            VERSION=$(gh release list --limit 1 --json tagName -q '.[0].tagName')
            
            if [ -z "$VERSION" ]; then
              echo "Error: No releases found. Please create a release first using the 'Create Release Version' workflow."
              exit 1
            fi
            
            echo "Using latest release: $VERSION"
          else
            # Use manual version
            VERSION="${{ github.event.inputs.manual_version }}"
            
            # Validate format
            if ! echo "$VERSION" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' > /dev/null; then
              echo "Error: Invalid version format. Expected format: vX.Y.Z (e.g., v3.28.0)"
              exit 1
            fi
            
            echo "Using manual version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Display version banner
          echo ""
          echo "╔════════════════════════════════════════╗"
          echo "║     BUILD VERSION: $VERSION           "
          echo "╚════════════════════════════════════════╝"
          echo ""
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if release exists
        id: check-release
        run: |
          VERSION="${{ steps.determine-version.outputs.version }}"
          
          # Check if the release exists
          if gh release view "$VERSION" > /dev/null 2>&1; then
            echo "✅ Release $VERSION exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            
            # Get release URL for reference
            RELEASE_URL=$(gh release view "$VERSION" --json url -q .url)
            echo "Release URL: $RELEASE_URL"
          else
            echo "⚠️ Warning: Release $VERSION does not exist yet"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Determine apps to build
        id: determine-apps
        run: |
          if [ "${{ github.event.inputs.app_selection }}" == "all" ]; then
            APPS='["ev.energy", "NGMA", "NGNY", "SVCE", "MCE", "ANWB"]'
            echo "Building all apps"
          else
            APPS='["${{ github.event.inputs.specific_app }}"]'
            echo "Building specific app: ${{ github.event.inputs.specific_app }}"
          fi
          
          echo "apps=$APPS" >> $GITHUB_OUTPUT
      
      - name: Display build information
        run: |
          echo "========================================="
          echo "📦 BUILD CONFIGURATION"
          echo "========================================="
          echo "Version: ${{ steps.determine-version.outputs.version }}"
          echo "Release Exists: ${{ steps.check-release.outputs.exists }}"
          echo "Apps to build: ${{ steps.determine-apps.outputs.apps }}"
          echo "========================================="
          
          # Parse and display apps in a readable format
          APPS='${{ steps.determine-apps.outputs.apps }}'
          echo ""
          echo "Apps list:"
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "  - $app"
          done
          echo ""
          echo "========================================="
  
  build-apps:
    needs: determine-build-parameters
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ${{ fromJson(needs.determine-build-parameters.outputs.apps) }}
        platform: [android, ios]
        environment: [staging, production]
    
    steps:
      - name: Prepare build configuration
        id: build-config
        run: |
          # Convert app name to lowercase and remove dots for workflow name
          APP_NAME="${{ matrix.app }}"
          APP_NAME_LOWER=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          APP_NAME_CLEAN=$(echo "$APP_NAME_LOWER" | tr -d '.')
          
          # Construct workflow name
          WORKFLOW_NAME="${APP_NAME_CLEAN}-${{ matrix.platform }}-${{ matrix.environment }}"
          
          # Release branch name
          BRANCH_NAME="release/${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "app_name_clean=$APP_NAME_CLEAN" >> $GITHUB_OUTPUT
          echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          echo "📱 Build Configuration:"
          echo "  App: ${{ matrix.app }}"
          echo "  Platform: ${{ matrix.platform }}"
          echo "  Environment: ${{ matrix.environment }}"
          echo "  Workflow: $WORKFLOW_NAME"
          echo "  Branch: $BRANCH_NAME"
          echo "  Version: ${{ needs.determine-build-parameters.outputs.version }}"
      
      - name: Trigger Bitrise build
        id: trigger-bitrise
        env:
          BITRISE_APP_ID: ${{ secrets.BITRISE_PROJECT_SLUG }}
          BITRISE_ACCESS_TOKEN: ${{ secrets.BITRISE_ACCESS_TOKEN }}
        run: |
          WORKFLOW_NAME="${{ steps.build-config.outputs.workflow_name }}"
          BRANCH_NAME="${{ steps.build-config.outputs.branch_name }}"
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "🚀 Triggering Bitrise build for $WORKFLOW_NAME"
          
          # Trigger Bitrise build using personal access token
          RESPONSE=$(curl -X POST "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds" \
            -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{
              \"hook_info\": {
                \"type\": \"bitrise\"
              },
              \"build_params\": {
                \"branch\": \"${BRANCH_NAME}\",
                \"workflow_id\": \"${WORKFLOW_NAME}\",
                \"environments\": [
                  {
                    \"mapped_to\": \"RELEASE_VERSION\",
                    \"value\": \"${VERSION}\",
                    \"is_expand\": true
                  },
                  {
                    \"mapped_to\": \"TRIGGERED_BY\",
                    \"value\": \"GitHub Actions - ${{ github.actor }}\",
                    \"is_expand\": true
                  }
                ],
                \"commit_message\": \"Build ${VERSION} - ${{ matrix.app }} (${{ matrix.platform }}/${{ matrix.environment }})\"
              }
            }")
          
          # Debug: Show full response structure
          echo "🔍 Full Bitrise API Response:"
          echo "$RESPONSE" | jq .
          
          # Extract build URL, status, build number, and public install page URL
          BUILD_URL=$(echo "$RESPONSE" | jq -r '.build_url // empty')
          BUILD_SLUG=$(echo "$RESPONSE" | jq -r '.build_slug // empty')
          BUILD_NUMBER=$(echo "$RESPONSE" | jq -r '.build_number // empty')
          PUBLIC_INSTALL_PAGE_URL=$(echo "$RESPONSE" | jq -r '.public_install_page_url // empty')
          STATUS=$(echo "$RESPONSE" | jq -r '.status // empty')
          
          if [ -z "$BUILD_URL" ] || [ "$STATUS" == "error" ]; then
            echo "❌ Failed to trigger Bitrise build"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          echo "✅ Bitrise build triggered successfully"
          echo "Build URL: $BUILD_URL"
          echo "Build Slug: $BUILD_SLUG"
          echo "Build Number: $BUILD_NUMBER"
          echo "Public Install Page: $PUBLIC_INSTALL_PAGE_URL"
          
          # Check available fields for install page
          echo "🔍 Checking for install page related fields:"
          echo "$RESPONSE" | jq 'keys[]' | grep -i install || echo "No install-related keys found"
          
          echo "build_url=$BUILD_URL" >> $GITHUB_OUTPUT
          echo "build_slug=$BUILD_SLUG" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "public_install_page_url=$PUBLIC_INSTALL_PAGE_URL" >> $GITHUB_OUTPUT
      
      - name: Wait for Bitrise build completion
        id: wait-for-completion
        run: |
          BUILD_SLUG="${{ steps.trigger-bitrise.outputs.build_slug }}"
          MAX_WAIT_TIME=3600  # 1 hour maximum wait time
          POLL_INTERVAL=30    # Check every 30 seconds
          elapsed_time=0
          
          echo "⏳ Waiting for Bitrise build to complete..."
          echo "Build Slug: $BUILD_SLUG"
          echo "Maximum wait time: ${MAX_WAIT_TIME} seconds"
          echo "API URL: https://api.bitrise.io/v0.1/apps/${{ secrets.BITRISE_PROJECT_SLUG }}/builds/${BUILD_SLUG}"
          
          while [ $elapsed_time -lt $MAX_WAIT_TIME ]; do
            # Get build status with HTTP status code
            HTTP_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -H "Authorization: token ${{ secrets.BITRISE_ACCESS_TOKEN }}" \
              "https://api.bitrise.io/v0.1/apps/${{ secrets.BITRISE_PROJECT_SLUG }}/builds/${BUILD_SLUG}")
            
            # Extract HTTP status and body
            HTTP_STATUS=$(echo "$HTTP_RESPONSE" | grep -o 'HTTPSTATUS:[0-9]*' | cut -d: -f2)
            STATUS_RESPONSE=$(echo "$HTTP_RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
            
            echo "HTTP Status: $HTTP_STATUS"
            
            # Check HTTP status first
            if [ "$HTTP_STATUS" != "200" ]; then
              echo "⚠️ HTTP $HTTP_STATUS from Bitrise API (elapsed: ${elapsed_time}s)"
              echo "Response body: $STATUS_RESPONSE"
              
              if [ "$HTTP_STATUS" = "404" ]; then
                echo "❌ Build not found (404) - build slug may be invalid"
                echo "final_status=not_found" >> $GITHUB_OUTPUT
                echo "build_completed=false" >> $GITHUB_OUTPUT
                exit 1
              elif [ "$HTTP_STATUS" = "401" ]; then
                echo "❌ Unauthorized (401) - check BITRISE_ACCESS_TOKEN"
                echo "final_status=unauthorized" >> $GITHUB_OUTPUT
                echo "build_completed=false" >> $GITHUB_OUTPUT
                exit 1
              fi
              
              # For other HTTP errors, wait and retry
              sleep $POLL_INTERVAL
              elapsed_time=$((elapsed_time + POLL_INTERVAL))
              continue
            fi
            
            # Check if response is valid JSON
            if ! echo "$STATUS_RESPONSE" | jq empty 2>/dev/null; then
              echo "⚠️ Invalid JSON response from Bitrise API (elapsed: ${elapsed_time}s)"
              echo "Response: $STATUS_RESPONSE"
              
              # Wait and retry for invalid JSON
              sleep $POLL_INTERVAL
              elapsed_time=$((elapsed_time + POLL_INTERVAL))
              continue
            fi
            
            BUILD_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.data.status_text // "unknown"')
            FINISHED_AT=$(echo "$STATUS_RESPONSE" | jq -r '.data.finished_at // null')
            
            echo "Build Status: $BUILD_STATUS (elapsed: ${elapsed_time}s)"
            
            # Check if build is finished (success or failed)
            if [ "$BUILD_STATUS" = "success" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ] || [ "$FINISHED_AT" != "null" ]; then
              echo "✅ Build finished with status: $BUILD_STATUS"
              
              # Debug: Show full build completion response
              echo "🔍 Full build completion response:"
              echo "$STATUS_RESPONSE" | jq .data
              
              # Extract final build details including public install page
              FINAL_PUBLIC_INSTALL_URL=$(echo "$STATUS_RESPONSE" | jq -r '.data.public_install_page_url // empty' 2>/dev/null || echo "")
              
              # Try alternative field names
              if [ -z "$FINAL_PUBLIC_INSTALL_URL" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "empty" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "null" ]; then
                echo "🔍 Trying alternative install page fields:"
                FINAL_PUBLIC_INSTALL_URL=$(echo "$STATUS_RESPONSE" | jq -r '.data.public_install_page // empty' 2>/dev/null || echo "")
                echo "public_install_page: $FINAL_PUBLIC_INSTALL_URL"
                
                if [ -z "$FINAL_PUBLIC_INSTALL_URL" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "empty" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "null" ]; then
                  FINAL_PUBLIC_INSTALL_URL=$(echo "$STATUS_RESPONSE" | jq -r '.data.install_page_url // empty' 2>/dev/null || echo "")
                  echo "install_page_url: $FINAL_PUBLIC_INSTALL_URL"
                fi
              fi
              
              echo "Final Public Install Page: $FINAL_PUBLIC_INSTALL_URL"
              echo "final_status=$BUILD_STATUS" >> $GITHUB_OUTPUT
              echo "final_public_install_url=$FINAL_PUBLIC_INSTALL_URL" >> $GITHUB_OUTPUT
              echo "build_completed=true" >> $GITHUB_OUTPUT
              
              # Fail the job if build failed or was aborted
              if [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ]; then
                echo "❌ Build failed with status: $BUILD_STATUS"
                exit 1
              fi
              
              break
            fi
            
            # Wait before next poll
            sleep $POLL_INTERVAL
            elapsed_time=$((elapsed_time + POLL_INTERVAL))
          done
          
          # Check if we timed out
          if [ $elapsed_time -ge $MAX_WAIT_TIME ]; then
            echo "⚠️ Build did not complete within ${MAX_WAIT_TIME} seconds"
            echo "final_status=timeout" >> $GITHUB_OUTPUT
            echo "build_completed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create build summary entry
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.wait-for-completion.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.wait-for-completion.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.wait-for-completion.outputs.final_public_install_url }}"
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ### ${{ matrix.app }} - ${{ matrix.platform }}/${{ matrix.environment }}
          - **Workflow**: \`${{ steps.build-config.outputs.workflow_name }}\`
          - **Branch**: \`${{ steps.build-config.outputs.branch_name }}\`
          EOF
          
          # Show final build status and install links
          if [ "$BUILD_COMPLETED" = "true" ]; then
            case "$FINAL_STATUS" in
              "success")
                if [ -n "$FINAL_INSTALL_URL" ] && [ "$FINAL_INSTALL_URL" != "null" ] && [ "$FINAL_INSTALL_URL" != "empty" ]; then
                  echo "- **Build Number**: [#$BUILD_NUMBER]($FINAL_INSTALL_URL) 📱" >> $GITHUB_STEP_SUMMARY
                  echo "- **Install Page**: [Download App]($FINAL_INSTALL_URL) 🎉" >> $GITHUB_STEP_SUMMARY
                  echo "- **Status**: ✅ **SUCCESS** - Ready to install!" >> $GITHUB_STEP_SUMMARY
                else
                  echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                  echo "- **Install Page**: _No install page available_" >> $GITHUB_STEP_SUMMARY
                  echo "- **Status**: ✅ **SUCCESS** - Check Bitrise for artifacts" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              "error")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build failed - no install page available_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ❌ **FAILED** - Check Bitrise for details" >> $GITHUB_STEP_SUMMARY
                ;;
              "aborted")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build was aborted_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ⚠️ **ABORTED**" >> $GITHUB_STEP_SUMMARY
                ;;
              "timeout")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build still in progress - check Bitrise_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ⏱️ **TIMEOUT** - Build taking longer than expected" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Status: $FINAL_STATUS_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ❓ **$FINAL_STATUS**" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Install Page**: _Build did not complete within timeout_" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ⏱️ **TIMEOUT**" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          - **Bitrise Build**: [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})
          
          EOF
      
      - name: Save build results for Slack notification
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.wait-for-completion.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.wait-for-completion.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.wait-for-completion.outputs.final_public_install_url }}"
          
          # Create build result JSON
          BUILD_RESULT=$(cat <<EOF
          {
            "app": "${{ matrix.app }}",
            "platform": "${{ matrix.platform }}",
            "environment": "${{ matrix.environment }}",
            "build_number": "$BUILD_NUMBER",
            "status": "$FINAL_STATUS",
            "completed": "$BUILD_COMPLETED",
            "install_url": "$FINAL_INSTALL_URL",
            "bitrise_url": "${{ steps.trigger-bitrise.outputs.build_url }}"
          }
          EOF
          )
          
          # Save to artifacts
          mkdir -p build-results
          echo "$BUILD_RESULT" > "build-results/${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}.json"
      
      - name: Upload build results
        uses: actions/upload-artifact@v4
        with:
          name: build-result-${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}
          path: build-results/
          retention-days: 7
  
  update-release:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: needs.determine-build-parameters.outputs.release_exists == 'true'
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Update release with build status
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "📝 Updating release $VERSION with build information"
          
          # Get current release notes
          gh release view "$VERSION" --json body -q .body > current_notes.md
          
          # Create updated notes with build status
          cat > updated_notes.md << EOF
          $(grep -B 1000 "## 📦 Build Status" current_notes.md | head -n -2 || cat current_notes.md)
          
          ## 📦 Build Status
          
          ✅ **Bitrise builds triggered** at $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ### Triggered Builds:
          EOF
          
          echo '```' >> updated_notes.md
          echo "$APPS" | jq -r '.[]' | while read app; do
            APP_LOWER=$(echo "$app" | tr '[:upper:]' '[:lower:]' | tr -d '.')
            echo "✓ $app" >> updated_notes.md
            echo "  - ${APP_LOWER}-android-staging" >> updated_notes.md
            echo "  - ${APP_LOWER}-android-production" >> updated_notes.md
            echo "  - ${APP_LOWER}-ios-staging" >> updated_notes.md
            echo "  - ${APP_LOWER}-ios-production" >> updated_notes.md
          done
          echo '```' >> updated_notes.md
          
          cat >> updated_notes.md << EOF
          
          **Build Details:**
          - Build Workflow: [Run #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - Release Branch: \`release/$VERSION\`
          - Triggered by: @${{ github.actor }}
          - Total Builds: $(echo "$APPS" | jq -r '. | length * 4') (4 per app: android/ios × staging/production)
          
          > **Note**: Check Bitrise for individual build statuses and artifacts.
          
          EOF
          
          # Add the rest of the original notes if there's content after Build Status
          if grep -A 1000 "## 📦 Build Status" current_notes.md | tail -n +3 | grep -q "^---"; then
            echo "" >> updated_notes.md
            grep -A 1000 "^---" current_notes.md >> updated_notes.md
          else
            echo "---" >> updated_notes.md
            echo "*This release was automatically generated by GitHub Actions*" >> updated_notes.md
          fi
          
          # Update the release
          gh release edit "$VERSION" --notes-file updated_notes.md
          
          echo "✅ Release $VERSION updated with Bitrise build status"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  summary:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Create job summary
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          RELEASE_EXISTS="${{ needs.determine-build-parameters.outputs.release_exists }}"
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # 🚀 Bitrise Build Summary
          
          ## 📋 Build Information
          
          | Field | Value |
          |-------|-------|
          | **Version** | \`$VERSION\` |
          | **Release Branch** | \`release/$VERSION\` |
          | **Version Source** | ${{ github.event.inputs.version_source }} |
          | **Release Exists** | $([ "$RELEASE_EXISTS" == "true" ] && echo "✅ Yes" || echo "⚠️ No") |
          | **App Selection** | ${{ github.event.inputs.app_selection }} |
          | **Triggered by** | @${{ github.actor }} |
          | **Workflow Run** | #${{ github.run_number }} |
          
          ## 📦 Bitrise Workflows Triggered
          
          | App | Platform | Environment | Workflow | Build # | Status |
          |-----|----------|-------------|----------|---------|--------|
          EOF
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            APP_LOWER=$(echo "$app" | tr '[:upper:]' '[:lower:]' | tr -d '.')
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                
                if [ -f "$BUILD_FILE" ]; then
                  BUILD_DATA=$(cat "$BUILD_FILE")
                  BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
                  INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
                  STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
                  COMPLETED=$(echo "$BUILD_DATA" | jq -r '.completed')
                  
                  # Format build number with hyperlink if available
                  if [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                    BUILD_DISPLAY="[#$BUILD_NUM]($INSTALL_URL)"
                  else
                    BUILD_DISPLAY="\`#$BUILD_NUM\`"
                  fi
                  
                  # Format status
                  case "$STATUS" in
                    "success") STATUS_DISPLAY="✅ SUCCESS" ;;
                    "error") STATUS_DISPLAY="❌ FAILED" ;;
                    "aborted") STATUS_DISPLAY="⚠️ ABORTED" ;;
                    "timeout") STATUS_DISPLAY="⏱️ TIMEOUT" ;;
                    *) STATUS_DISPLAY="❓ $STATUS" ;;
                  esac
                  
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | $BUILD_DISPLAY | $STATUS_DISPLAY |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | _No data_ | ❓ Unknown |" >> $GITHUB_STEP_SUMMARY
                fi
              done
            done
          done
          
          # Calculate total builds
          TOTAL_APPS=$(echo "$APPS" | jq -r '. | length')
          TOTAL_BUILDS=$((TOTAL_APPS * 4))
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          
          ## 📊 Summary
          
          - **Total Apps**: $TOTAL_APPS
          - **Builds per App**: 4 (2 platforms × 2 environments)
          - **Total Builds Triggered**: $TOTAL_BUILDS
          
          ## 🔗 Links
          
          EOF
          
          if [ "$RELEASE_EXISTS" == "true" ]; then
            echo "- [View Release](https://github.com/${{ github.repository }}/releases/tag/$VERSION)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ No release found for version $VERSION" >> $GITHUB_STEP_SUMMARY
            echo "- [Create Release](https://github.com/${{ github.repository }}/actions/workflows/create-release-version.yml)" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          - [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Bitrise Dashboard](https://app.bitrise.io/dashboard)
          
          ## ⚠️ Important Notes
          
          1. **Build Numbers**: Individual Bitrise build numbers are shown in the build details above
          2. **Install Pages**: Public install page links are available in the build details above (after build completion)
          3. **Check Bitrise** for individual build statuses and download artifacts
          4. **Release Branch**: All builds are from \`release/$VERSION\`
          5. **Workflow Naming**: Follows pattern \`{app}-{platform}-{environment}\`
          
          ---
          *Builds triggered at $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF
  
  slack-notification:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Prepare Slack message
        id: slack-message
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "📱 Preparing Slack message for release $VERSION"
                   
          # Process build results by app
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "Processing app: $app"
            
            # Process builds for this app
            STAGING_ANDROID="N/A"
            STAGING_IOS="N/A"
            PROD_ANDROID="N/A"
            PROD_IOS="N/A"
            
            # Check for Android staging
            if [ -f "build-results/${app}-android-staging.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-android-staging.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              
              if [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                STAGING_ANDROID="<$INSTALL_URL|$BUILD_NUM>"
              else
                STAGING_ANDROID="$BUILD_NUM"
              fi
            fi
            
            # Check for iOS staging
            if [ -f "build-results/${app}-ios-staging.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-ios-staging.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              
              if [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                STAGING_IOS="<$INSTALL_URL|$BUILD_NUM>"
              else
                STAGING_IOS="$BUILD_NUM"
              fi
            fi
            
            # Check for Android production
            if [ -f "build-results/${app}-android-production.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-android-production.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              
              if [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                PROD_ANDROID="<$INSTALL_URL|$BUILD_NUM>"
              else
                PROD_ANDROID="$BUILD_NUM"
              fi
            fi
            
            # Check for iOS production
            if [ -f "build-results/${app}-ios-production.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-ios-production.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              
              if [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                PROD_IOS="<$INSTALL_URL|$BUILD_NUM>"
              else
                PROD_IOS="$BUILD_NUM"
              fi
            fi
            
            # Append to message file
            cat >> slack_message.txt << EOF
          • *$app*
            ▸ *Staging:* :android: $STAGING_ANDROID  :appleinc: $STAGING_IOS
            ▸ *Production:* :android: $PROD_ANDROID  :appleinc: $PROD_IOS
          EOF
          
          done
          
          # Add footer
          cat >> slack_message.txt << EOF
          
          :rocket: *Release:* $VERSION
          :github: *Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run #${{ github.run_number }}>
          EOF
          
          echo "Final Slack message:"
          cat slack_message.txt
      
      - name: Send Slack notification
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "⚠️ SLACK_WEBHOOK_URL not configured - skipping Slack notification"
            exit 0
          fi
          
          echo "📤 Sending Slack notification..."
          
          # Read the message and escape for JSON
          MESSAGE_CONTENT=$(cat slack_message.txt | jq -Rs .)
          
          # Determine channel (use override if specified, otherwise webhook default)
          CHANNEL_OVERRIDE=""
          if [ -n "$SLACK_CHANNEL" ]; then
            CHANNEL_OVERRIDE=",\"channel\": \"$SLACK_CHANNEL\""
            echo "🎯 Overriding channel to: $SLACK_CHANNEL"
          else
            echo "📍 Using webhook default channel"
          fi
          
          # Create JSON payload with optional channel override
          PAYLOAD=$(cat << EOF
          {
            "text": "🚀 Build Results for Release ${{ needs.determine-build-parameters.outputs.version }}"$CHANNEL_OVERRIDE,
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": $MESSAGE_CONTENT
                }
              }
            ]
          }
          EOF
          )
          
          echo "Payload preview:"
          echo "$PAYLOAD" | jq .
          
          # Send to Slack
          RESPONSE=$(curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL")
          
          if [ "$RESPONSE" = "ok" ]; then
            echo "✅ Slack notification sent successfully!"
          else
            echo "❌ Failed to send Slack notification. Response: $RESPONSE"
            exit 1
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL }}