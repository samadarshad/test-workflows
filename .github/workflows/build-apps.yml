# Build Apps Workflow
# 
# This workflow builds mobile apps using Bitrise for multiple apps, platforms, and environments.
# 
# Required Secrets:
# - BITRISE_PROJECT_SLUG: Bitrise project identifier
# - BITRISE_ACCESS_TOKEN: Bitrise API access token
# - SLACK_WEBHOOK_URL: Slack webhook for notifications (optional)
#
# Required Repository Variables (for app-specific connected app IDs):
# - BITRISE_CONNECTED_APP_ID_EV_ENERGY: Connected app ID for ev.energy Android builds
# - BITRISE_CONNECTED_APP_ID_NGMA: Connected app ID for NGMA Android builds
# - BITRISE_CONNECTED_APP_ID_NGNY: Connected app ID for NGNY Android builds
# - BITRISE_CONNECTED_APP_ID_SVCE: Connected app ID for SVCE Android builds
# - BITRISE_CONNECTED_APP_ID_MCE: Connected app ID for MCE Android builds
# - BITRISE_CONNECTED_APP_ID_ANWB: Connected app ID for ANWB Android builds
#
# Set these at: Settings > Secrets and variables > Actions > Variables tab
# Each app requires its own specific connected app ID variable

name: Build Apps

run-name: "Build Apps: ${{ github.event.inputs.version_source == 'latest' && 'Latest Release' || github.event.inputs.manual_version }} - ${{ github.event.inputs.app_selection == 'all' && 'All apps' || github.event.inputs.specific_app }}"

on:
  workflow_dispatch:
    inputs:
      version_source:
        description: 'Version source'
        required: true
        type: choice
        options:
          - latest
          - manual
        default: latest
      
      manual_version:
        description: 'Manual version (e.g., v3.28.0) - only used if version_source is "manual"'
        required: false
        type: string
      
      app_selection:
        description: 'Apps to build'
        required: true
        type: choice
        options:
          - all
          - specific
        default: all
      
      specific_app:
        description: 'Specific app name (only used if app_selection is "specific")'
        required: false
        type: choice
        options:
          - ev.energy
          - NGMA
          - NGNY
          - SVCE
          - MCE
          - ANWB
        default: ev.energy

jobs:
  determine-build-parameters:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.determine-version.outputs.version }}
      apps: ${{ steps.determine-apps.outputs.apps }}
      release_exists: ${{ steps.check-release.outputs.exists }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine version to build
        id: determine-version
        run: |
          if [ "${{ github.event.inputs.version_source }}" == "latest" ]; then
            # Get the latest release tag
            VERSION=$(gh release list --limit 1 --json tagName -q '.[0].tagName')
            
            if [ -z "$VERSION" ]; then
              echo "Error: No releases found. Please create a release first using the 'Create Release Version' workflow."
              exit 1
            fi
            
            echo "Using latest release: $VERSION"
          else
            # Use manual version
            VERSION="${{ github.event.inputs.manual_version }}"
            
            # Validate format
            if ! echo "$VERSION" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)*$' > /dev/null; then
              echo "Error: Invalid version format. Expected format: vX.Y.Z or vX.Y.Z-suffix (e.g., v3.28.0 or v3.29.0-abc)"
              exit 1
            fi
            
            echo "Using manual version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Display version banner
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘     BUILD VERSION: $VERSION           "
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if release exists
        id: check-release
        run: |
          VERSION="${{ steps.determine-version.outputs.version }}"
          
          # Check if the release exists
          if gh release view "$VERSION" > /dev/null 2>&1; then
            echo "âœ… Release $VERSION exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            
            # Get release URL for reference
            RELEASE_URL=$(gh release view "$VERSION" --json url -q .url)
            echo "Release URL: $RELEASE_URL"
          else
            echo "âš ï¸ Warning: Release $VERSION does not exist yet"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Determine apps to build
        id: determine-apps
        run: |
          if [ "${{ github.event.inputs.app_selection }}" == "all" ]; then
            APPS='["ev.energy", "NGMA", "NGNY", "SVCE", "MCE", "ANWB"]'
            echo "Building all apps"
          else
            APPS='["${{ github.event.inputs.specific_app }}"]'
            echo "Building specific app: ${{ github.event.inputs.specific_app }}"
          fi
          
          echo "apps=$APPS" >> $GITHUB_OUTPUT
      
      - name: ðŸ“‹ Build Summary
        run: |
          VERSION="${{ steps.determine-version.outputs.version }}"
          RELEASE_EXISTS="${{ steps.check-release.outputs.exists }}"
          APPS='${{ steps.determine-apps.outputs.apps }}'
          
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                        ï¿½ BUILD SUMMARY                      â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ðŸ·ï¸  RELEASE VERSION: $VERSION"
          echo "ðŸ“¦ RELEASE STATUS:   $([ "$RELEASE_EXISTS" == "true" ] && echo "âœ… Exists" || echo "âš ï¸  Not found")"
          echo "ðŸŽ¯ BUILD STRATEGY:   ${{ github.event.inputs.version_source == 'latest' && 'Latest Release' || 'Manual Version' }}"
          echo "ðŸ“± APP SELECTION:    ${{ github.event.inputs.app_selection == 'all' && 'All Apps' || 'Single App' }}"
          echo "ðŸ‘¤ TRIGGERED BY:     @${{ github.actor }}"
          echo "ðŸ• STARTED AT:       $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""
          echo "ðŸ“‹ APPS TO BUILD:"
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "   â€¢ $app"
          done
          echo ""
          
          # Calculate total builds
          APP_COUNT=$(echo "$APPS" | jq -r '. | length')
          TOTAL_BUILDS=$((APP_COUNT * 4))
          
          echo "ðŸ“Š BUILD DETAILS:"
          echo "   â€¢ Total Apps: $APP_COUNT"
          echo "   â€¢ Platforms: Android & iOS"
          echo "   â€¢ Environments: Staging & Production"
          echo "   â€¢ Total Builds: $TOTAL_BUILDS"
          echo ""
          echo "ðŸ”— REFERENCE LINKS:"
          if [ "$RELEASE_EXISTS" == "true" ]; then
            echo "   â€¢ Release: https://github.com/${{ github.repository }}/releases/tag/$VERSION"
          else
            echo "   â€¢ âš ï¸  Release not found - will be created during build process"
          fi
          echo "   â€¢ Workflow: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "   â€¢ Repository: https://github.com/${{ github.repository }}"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸš€ Starting Bitrise builds for $TOTAL_BUILDS workflows..."
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Create GitHub Step Summary
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ðŸš€ Build Summary
          
          ## ðŸ“‹ Build Configuration
          
          | Field | Value |
          |-------|-------|
          | **Release Version** | \`$VERSION\` |
          | **Release Exists** | $([ "$RELEASE_EXISTS" == "true" ] && echo "âœ… Yes" || echo "âš ï¸ No") |
          | **Build Strategy** | ${{ github.event.inputs.version_source == 'latest' && 'Latest Release' || 'Manual Version' }} |
          | **App Selection** | ${{ github.event.inputs.app_selection == 'all' && 'All Apps' || 'Single App' }} |
          | **Triggered By** | @${{ github.actor }} |
          | **Started At** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |
          
          ## ðŸ“± Apps to Build
          
          EOF
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "- **$app** (Android + iOS, Staging + Production)" >> $GITHUB_STEP_SUMMARY
          done
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          
          ## ðŸ“Š Build Overview
          
          - **Total Apps**: $APP_COUNT
          - **Platforms**: Android & iOS
          - **Environments**: Staging & Production  
          - **Total Builds**: $TOTAL_BUILDS
          
          ## ðŸ”— Links
          
          EOF
          
          if [ "$RELEASE_EXISTS" == "true" ]; then
            echo "- [ðŸ“¦ Release $VERSION](https://github.com/${{ github.repository }}/releases/tag/$VERSION)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- âš ï¸ Release $VERSION not found (will be created during build)" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          - [ðŸ”„ Workflow Run #${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [ðŸ“‚ Repository](https://github.com/${{ github.repository }})
          
          ---
          
          **Next**: Triggering $TOTAL_BUILDS Bitrise builds across all apps, platforms, and environments...
          
          ## ðŸ”— Where to Find Bitrise Links
          
          1. **Individual Build Steps**: Each build will show its Bitrise link in its own step summary below
          2. **Consolidated Links**: Check the "Complete Bitrise Dashboard" job for all links in one place (appears after all builds are triggered)
          3. **Bitrise Dashboard**: [Open Bitrise Dashboard](https://app.bitrise.io/dashboard) to see all builds
          
          ---
          EOF
  
  bitrise-links-collector:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Wait for all builds to be triggered
        run: |
          echo "â³ Waiting for all Bitrise builds to be triggered..."
          echo "This job will collect all build information once available."
          sleep 10  # Brief pause to ensure artifacts are uploaded
      
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: ðŸ”— Complete Bitrise Dashboard
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ï¿½ Bitrise Builds - Quick Access Links
          
          ## ðŸ“± All Build Links for $VERSION
          
          > **ï¿½ Click any link below to access Bitrise builds directly**
          
          | App | Platform | Environment | Build # | Status | Bitrise Link |
          |-----|----------|-------------|---------|--------|--------------|
          EOF
          
          # Process build results to show Bitrise links
          echo "$APPS" | jq -r '.[]' | while read app; do
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                
                if [ -f "$BUILD_FILE" ]; then
                  BUILD_DATA=$(cat "$BUILD_FILE")
                  BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number // "N/A"')
                  STATUS=$(echo "$BUILD_DATA" | jq -r '.status // "unknown"')
                  BITRISE_URL=$(echo "$BUILD_DATA" | jq -r '.bitrise_url // empty')
                  
                  # Format status emoji
                  case "$STATUS" in
                    "success") STATUS_DISPLAY="âœ… Success" ;;
                    "error") STATUS_DISPLAY="âŒ Failed" ;;
                    "aborted") STATUS_DISPLAY="âš ï¸ Aborted" ;;
                    "timeout") STATUS_DISPLAY="â±ï¸ Timeout" ;;
                    *) STATUS_DISPLAY="ðŸ”„ $STATUS" ;;
                  esac
                  
                  # Create Bitrise link
                  if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                    BITRISE_LINK="[ðŸ”— View Build]($BITRISE_URL)"
                  else
                    BITRISE_LINK="_No link available_"
                  fi
                  
                  echo "| $app | $platform | $env | #$BUILD_NUM | $STATUS_DISPLAY | $BITRISE_LINK |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| $app | $platform | $env | _N/A_ | â“ Not triggered | _No build_ |" >> $GITHUB_STEP_SUMMARY
                fi
              done
            done
          done
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          
          ## ï¿½ Quick Actions
          
          - [ðŸ“± Bitrise Dashboard](https://app.bitrise.io/dashboard) - View all your builds in one place
          - [ðŸ“¦ Release $VERSION](https://github.com/${{ github.repository }}/releases/tag/$VERSION) $([ "${{ needs.determine-build-parameters.outputs.release_exists }}" == "true" ] && echo "" || echo "(âš ï¸ Not found)")
          - [ðŸ”„ Workflow Run #${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ## ðŸ“‹ Build Summary
          
          - **Version**: \`$VERSION\`
          - **Triggered by**: @${{ github.actor }}
          - **Completed**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ---
          
          **ðŸ’¡ Pro Tip**: Bookmark the Bitrise Dashboard link above to quickly access all your builds across projects!
          EOF
  
  build-apps:
    needs: determine-build-parameters
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.determine-build-parameters.outputs.apps) }}
        platform: [android, ios]
        environment: [staging, production]
    
    steps:
      - name: Prepare build configuration
        id: build-config
        run: |
          # Convert app name to lowercase and remove dots for workflow name
          APP_NAME="${{ matrix.app }}"
          APP_NAME_LOWER=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          APP_NAME_CLEAN=$(echo "$APP_NAME_LOWER" | tr -d '.')
          
          # Construct workflow name
          WORKFLOW_NAME="${APP_NAME_CLEAN}-${{ matrix.platform }}-${{ matrix.environment }}"
          
          # Release branch name
          BRANCH_NAME="release/${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "app_name_clean=$APP_NAME_CLEAN" >> $GITHUB_OUTPUT
          echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          echo "ðŸ“± Build Configuration:"
          echo "  App: ${{ matrix.app }}"
          echo "  Platform: ${{ matrix.platform }}"
          echo "  Environment: ${{ matrix.environment }}"
          echo "  Workflow: $WORKFLOW_NAME"
          echo "  Branch: $BRANCH_NAME"
          echo "  Version: ${{ needs.determine-build-parameters.outputs.version }}"
      
      - name: Trigger Bitrise build
        id: trigger-bitrise
        env:
          BITRISE_APP_ID: ${{ secrets.BITRISE_PROJECT_SLUG }}
          BITRISE_ACCESS_TOKEN: ${{ secrets.BITRISE_ACCESS_TOKEN }}
        run: |
          WORKFLOW_NAME="${{ steps.build-config.outputs.workflow_name }}"
          BRANCH_NAME="${{ steps.build-config.outputs.branch_name }}"
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "ðŸš€ Triggering Bitrise build for $WORKFLOW_NAME"
          
          # Trigger Bitrise build using personal access token
          RESPONSE=$(curl -X POST "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds" \
            -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{
              \"hook_info\": {
                \"type\": \"bitrise\"
              },
              \"build_params\": {
                \"branch\": \"${BRANCH_NAME}\",
                \"workflow_id\": \"${WORKFLOW_NAME}\",
                \"environments\": [
                  {
                    \"mapped_to\": \"RELEASE_VERSION\",
                    \"value\": \"${VERSION}\",
                    \"is_expand\": true
                  },
                  {
                    \"mapped_to\": \"TRIGGERED_BY\",
                    \"value\": \"GitHub Actions - ${{ github.actor }}\",
                    \"is_expand\": true
                  }
                ],
                \"commit_message\": \"Build ${VERSION} - ${{ matrix.app }} (${{ matrix.platform }}/${{ matrix.environment }})\"
              }
            }")
          
          # Debug: Show full response structure
          echo "ðŸ” Full Bitrise API Response:"
          echo "$RESPONSE" | jq .
          
          # Extract build URL, status, build number, and public install page URL
          BUILD_URL=$(echo "$RESPONSE" | jq -r '.build_url // empty')
          BUILD_SLUG=$(echo "$RESPONSE" | jq -r '.build_slug // empty')
          BUILD_NUMBER=$(echo "$RESPONSE" | jq -r '.build_number // empty')
          PUBLIC_INSTALL_PAGE_URL=$(echo "$RESPONSE" | jq -r '.public_install_page_url // empty')
          STATUS=$(echo "$RESPONSE" | jq -r '.status // empty')
          
          if [ -z "$BUILD_URL" ] || [ "$STATUS" == "error" ]; then
            echo "âŒ Failed to trigger Bitrise build"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          echo "âœ… Bitrise build triggered successfully"
          echo "Build URL: $BUILD_URL"
          echo "Build Slug: $BUILD_SLUG"
          echo "Build Number: $BUILD_NUMBER"
          echo "Public Install Page: $PUBLIC_INSTALL_PAGE_URL"
          
          # Check available fields for install page
          echo "ðŸ” Checking for install page related fields:"
          echo "$RESPONSE" | jq 'keys[]' | grep -i install || echo "No install-related keys found"
          
          echo "build_url=$BUILD_URL" >> $GITHUB_OUTPUT
          echo "build_slug=$BUILD_SLUG" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "public_install_page_url=$PUBLIC_INSTALL_PAGE_URL" >> $GITHUB_OUTPUT
      
      - name: Save build slug for cancellation
        run: |
          BUILD_SLUG="${{ steps.trigger-bitrise.outputs.build_slug }}"
          
          # Create build slug info for cancellation purposes
          BUILD_INFO=$(cat <<EOF
          {
            "app": "${{ matrix.app }}",
            "platform": "${{ matrix.platform }}",
            "environment": "${{ matrix.environment }}",
            "build_slug": "$BUILD_SLUG",
            "build_url": "${{ steps.trigger-bitrise.outputs.build_url }}",
            "workflow_name": "${{ steps.build-config.outputs.workflow_name }}",
            "triggered_at": "$(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          }
          EOF
          )
          
          # Save to cancellation artifacts directory
          mkdir -p build-slugs
          echo "$BUILD_INFO" > "build-slugs/${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}.json"
      
      - name: Upload build slug for cancellation
        uses: actions/upload-artifact@v4
        with:
          name: build-slug-${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}
          path: build-slugs/
          retention-days: 1
      
      - name: Wait for Bitrise build completion
        id: wait-for-completion
        run: |
          BUILD_SLUG="${{ steps.trigger-bitrise.outputs.build_slug }}"
          MAX_WAIT_TIME=3600  # 1 hour maximum wait time
          POLL_INTERVAL=30    # Check every 30 seconds
          elapsed_time=0
          
          echo "â³ Waiting for Bitrise build to complete..."
          echo "Build Slug: $BUILD_SLUG"
          echo "Maximum wait time: ${MAX_WAIT_TIME} seconds"
          echo "API URL: https://api.bitrise.io/v0.1/apps/${{ secrets.BITRISE_PROJECT_SLUG }}/builds/${BUILD_SLUG}"
          
          while [ $elapsed_time -lt $MAX_WAIT_TIME ]; do
            # Get build status with HTTP status code
            HTTP_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -H "Authorization: token ${{ secrets.BITRISE_ACCESS_TOKEN }}" \
              "https://api.bitrise.io/v0.1/apps/${{ secrets.BITRISE_PROJECT_SLUG }}/builds/${BUILD_SLUG}")
            
            # Extract HTTP status and body
            HTTP_STATUS=$(echo "$HTTP_RESPONSE" | grep -o 'HTTPSTATUS:[0-9]*' | cut -d: -f2)
            STATUS_RESPONSE=$(echo "$HTTP_RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
            
            echo "HTTP Status: $HTTP_STATUS"
            
            # Check HTTP status first
            if [ "$HTTP_STATUS" != "200" ]; then
              echo "âš ï¸ HTTP $HTTP_STATUS from Bitrise API (elapsed: ${elapsed_time}s)"
              echo "Response body: $STATUS_RESPONSE"
              
              if [ "$HTTP_STATUS" = "404" ]; then
                echo "âŒ Build not found (404) - build slug may be invalid"
                echo "final_status=not_found" >> $GITHUB_OUTPUT
                echo "build_completed=false" >> $GITHUB_OUTPUT
                exit 1
              elif [ "$HTTP_STATUS" = "401" ]; then
                echo "âŒ Unauthorized (401) - check BITRISE_ACCESS_TOKEN"
                echo "final_status=unauthorized" >> $GITHUB_OUTPUT
                echo "build_completed=false" >> $GITHUB_OUTPUT
                exit 1
              fi
              
              # For other HTTP errors, wait and retry
              sleep $POLL_INTERVAL
              elapsed_time=$((elapsed_time + POLL_INTERVAL))
              continue
            fi
            
            # Check if response is valid JSON
            if ! echo "$STATUS_RESPONSE" | jq empty 2>/dev/null; then
              echo "âš ï¸ Invalid JSON response from Bitrise API (elapsed: ${elapsed_time}s)"
              echo "Response: $STATUS_RESPONSE"
              
              # Wait and retry for invalid JSON
              sleep $POLL_INTERVAL
              elapsed_time=$((elapsed_time + POLL_INTERVAL))
              continue
            fi
            
            BUILD_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.data.status_text // "unknown"')
            FINISHED_AT=$(echo "$STATUS_RESPONSE" | jq -r '.data.finished_at // null')
            
            echo "Build Status: $BUILD_STATUS (elapsed: ${elapsed_time}s)"
            
            # Check if build is finished (success or failed)
            if [ "$BUILD_STATUS" = "success" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ] || [ "$FINISHED_AT" != "null" ]; then
              echo "âœ… Build finished with status: $BUILD_STATUS"
              
              # Debug: Show full build completion response (only for Android)
              if [ "${{ matrix.platform }}" = "android" ]; then
                echo "ðŸ” Full build completion response:"
                echo "$STATUS_RESPONSE" | jq .data
              fi
              
              echo "final_status=$BUILD_STATUS" >> $GITHUB_OUTPUT
              echo "build_completed=true" >> $GITHUB_OUTPUT
              
              # Note build failure but don't exit - let summary steps run
              if [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ]; then
                echo "âŒ Build failed with status: $BUILD_STATUS"
                echo "build_failed=true" >> $GITHUB_OUTPUT
              else
                echo "build_failed=false" >> $GITHUB_OUTPUT
              fi
              
              break
            fi
            
            # Wait before next poll
            sleep $POLL_INTERVAL
            elapsed_time=$((elapsed_time + POLL_INTERVAL))
          done
          
          # Check if we timed out
          if [ $elapsed_time -ge $MAX_WAIT_TIME ]; then
            echo "âš ï¸ Build did not complete within ${MAX_WAIT_TIME} seconds"
            echo "final_status=timeout" >> $GITHUB_OUTPUT
            echo "build_completed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Resolve connected app ID for Android
        id: resolve-connected-app-id
        if: matrix.platform == 'android'
        run: |
          APP_NAME="${{ matrix.app }}"
          
          # Convert app name to a valid variable name format (uppercase, replace dots with underscores)
          APP_VAR_NAME=$(echo "$APP_NAME" | tr '[:lower:]' '[:upper:]' | tr '.' '_')
          
          echo "ðŸ” Resolving connected app ID for app: $APP_NAME"
          echo "Looking for variable: BITRISE_CONNECTED_APP_ID_${APP_VAR_NAME}"
          
          # Get app-specific connected app ID from variables
          case "$APP_VAR_NAME" in
            "EV_ENERGY")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_EV_ENERGY }}"
              ;;
            "NGMA")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_NGMA }}"
              ;;
            "NGNY")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_NGNY }}"
              ;;
            "SVCE")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_SVCE }}"
              ;;
            "MCE")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_MCE }}"
              ;;
            "ANWB")
              CONNECTED_APP_ID="${{ vars.BITRISE_CONNECTED_APP_ID_ANWB }}"
              ;;
            *)
              echo "âš ï¸ Unknown app: $APP_NAME - no connected app ID configured"
              CONNECTED_APP_ID=""
              ;;
          esac
          
          if [ -n "$CONNECTED_APP_ID" ]; then
            echo "âœ… Using connected app ID: ${CONNECTED_APP_ID:0:8}... (for $APP_NAME)"
            echo "connected_app_id=$CONNECTED_APP_ID" >> $GITHUB_OUTPUT
          else
            echo "âŒ No connected app ID found for $APP_NAME"
            echo "ðŸ’¡ Set BITRISE_CONNECTED_APP_ID_${APP_VAR_NAME} repository variable"
            echo "connected_app_id=" >> $GITHUB_OUTPUT
          fi
      
      - name: Get public install page URL
        id: get-install-url
        if: matrix.platform == 'android' && steps.wait-for-completion.outputs.build_completed == 'true' && steps.wait-for-completion.outputs.final_status == 'success'
        run: |
          echo "ðŸ¤– Android build successful - using Release Management API to get public install page URL..."
          
          # Poll for install page URL using Release Management API
          INSTALL_PAGE_WAIT_TIME=180  # 3 minutes max wait for install page
          INSTALL_PAGE_POLL_INTERVAL=15  # Check every 15 seconds
          install_page_elapsed=0
          
          # Extract build number for Release Management API search
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          
          echo "ðŸ” Searching Release Management API with build number: $BUILD_NUMBER"
          
          FINAL_PUBLIC_INSTALL_URL=""
          
          while [ $install_page_elapsed -lt $INSTALL_PAGE_WAIT_TIME ]; do
            echo "ðŸ” Checking Release Management API for install page URL (elapsed: ${install_page_elapsed}s)..."
            
            # Use Release Management API to find installable artifacts
            # Use the app-specific connected app ID resolved earlier
            CONNECTED_APP_ID="${{ steps.resolve-connected-app-id.outputs.connected_app_id }}"
            
            if [ -n "$CONNECTED_APP_ID" ]; then
              # Search by build number only
              RELEASE_MGMT_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.BITRISE_ACCESS_TOKEN }}" \
                "https://api.bitrise.io/release-management/v1/connected-apps/${CONNECTED_APP_ID}/installable-artifacts?items_per_page=20&page=1&search=${BUILD_NUMBER}")
              
              echo "ðŸ” Release Management API response:"
              echo "$RELEASE_MGMT_RESPONSE" | jq . || echo "Invalid JSON response"
              
              if echo "$RELEASE_MGMT_RESPONSE" | jq empty 2>/dev/null; then
                # Check if we got any items
                ITEM_COUNT=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r '.count // 0')
                echo "Found $ITEM_COUNT installable artifact(s)"
                
                if [ "$ITEM_COUNT" -gt 0 ]; then
                  # Find the exact artifact matching the build number and platform
                  FINAL_PUBLIC_INSTALL_URL=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg build_num "$BUILD_NUMBER" \
                    '.items[] | select(.build_number == $build_num) | select(.platform == "android") | select(.public_install_page_url != null) | .public_install_page_url' | head -1)
                  
                  # Check if we found a valid URL
                  if [ -n "$FINAL_PUBLIC_INSTALL_URL" ] && [ "$FINAL_PUBLIC_INSTALL_URL" != "empty" ] && [ "$FINAL_PUBLIC_INSTALL_URL" != "null" ]; then
                    echo "âœ… Found install page URL from Release Management API: $FINAL_PUBLIC_INSTALL_URL"
                    
                    # Show which artifact we matched
                    MATCHED_ARTIFACT=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg url "$FINAL_PUBLIC_INSTALL_URL" \
                      '.items[] | select(.public_install_page_url == $url) | "\(.app_name) - \(.workflow) - \(.filename) - Build #\(.build_number)"')
                    echo "ðŸ“± Matched artifact: $MATCHED_ARTIFACT"
                    break
                  else
                    echo "âš ï¸ No public install page URL found for Android artifact with build number $BUILD_NUMBER"
                  fi
                else
                  echo "âš ï¸ No installable artifacts found for build $BUILD_NUMBER"
                fi
              fi
            else
              echo "âš ï¸ Connected app ID not available - Release Management API unavailable"
              echo "ðŸ’¡ Set BITRISE_CONNECTED_APP_ID_${APP_VAR_NAME} repository variable"
            fi
            
            echo "â³ Install page URL not ready yet, waiting ${INSTALL_PAGE_POLL_INTERVAL}s..."
            sleep $INSTALL_PAGE_POLL_INTERVAL
            install_page_elapsed=$((install_page_elapsed + INSTALL_PAGE_POLL_INTERVAL))
          done
          
          # Check if we timed out waiting for install page
          if [ $install_page_elapsed -ge $INSTALL_PAGE_WAIT_TIME ] && ([ -z "$FINAL_PUBLIC_INSTALL_URL" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "empty" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "null" ]); then
            echo "âš ï¸ Timed out waiting for install page URL after ${INSTALL_PAGE_WAIT_TIME}s"
            echo "ðŸŽ¯ Note: Install page may still become available later - check Bitrise dashboard"
            echo "ðŸ’¡ Tip: Ensure correct connected app ID is configured for ${{ matrix.app }}"
            FINAL_PUBLIC_INSTALL_URL=""
          fi
          
          echo "Final Public Install Page: $FINAL_PUBLIC_INSTALL_URL"
          echo "install_url=$FINAL_PUBLIC_INSTALL_URL" >> $GITHUB_OUTPUT
      
      - name: Create build summary entry
        if: always()
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.wait-for-completion.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.wait-for-completion.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.get-install-url.outputs.install_url }}"
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ### ${{ matrix.app }} - ${{ matrix.platform }}/${{ matrix.environment }}
          - **Workflow**: \`${{ steps.build-config.outputs.workflow_name }}\`
          - **Branch**: \`${{ steps.build-config.outputs.branch_name }}\`
          EOF
          
          # Check if build was even triggered
          if [ -z "$BUILD_NUMBER" ]; then
            echo "- **Build Number**: _Build not triggered_" >> $GITHUB_STEP_SUMMARY
            echo "- **Install Page**: _No build available_" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: âŒ **FAILED** - Build trigger failed" >> $GITHUB_STEP_SUMMARY
            echo "- **Bitrise Build**: _No build URL available_" >> $GITHUB_STEP_SUMMARY
          elif [ "$BUILD_COMPLETED" = "true" ]; then
            case "$FINAL_STATUS" in
              "success")
                if [ "${{ matrix.platform }}" = "android" ]; then
                  # Android builds should have install pages
                  if [ -n "$FINAL_INSTALL_URL" ] && [ "$FINAL_INSTALL_URL" != "null" ] && [ "$FINAL_INSTALL_URL" != "empty" ]; then
                    echo "- **Build Number**: [#$BUILD_NUMBER]($FINAL_INSTALL_URL) ðŸ“±" >> $GITHUB_STEP_SUMMARY
                    echo "- **Install Page**: [Download APK]($FINAL_INSTALL_URL) ðŸ¤–" >> $GITHUB_STEP_SUMMARY
                    echo "- **Status**: âœ… **SUCCESS** - Ready to install!" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                    echo "- **Install Page**: _No install page available_" >> $GITHUB_STEP_SUMMARY
                    echo "- **Status**: âœ… **SUCCESS** - Check Bitrise for APK" >> $GITHUB_STEP_SUMMARY
                  fi
                else
                  # iOS builds don't need install pages
                  echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                  echo "- **Install Page**: _iOS build (TestFlight/App Store)_ ðŸŽ" >> $GITHUB_STEP_SUMMARY
                  echo "- **Status**: âœ… **SUCCESS** - Check Bitrise for artifacts" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              "error")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build failed - no install page available_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: âŒ **FAILED** - [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})" >> $GITHUB_STEP_SUMMARY
                ;;
              "aborted")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build was aborted_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: âš ï¸ **ABORTED** - [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})" >> $GITHUB_STEP_SUMMARY
                ;;
              "timeout")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build still in progress - check Bitrise_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: â±ï¸ **TIMEOUT** - Build taking longer than expected" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Status: $FINAL_STATUS_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: â“ **$FINAL_STATUS**" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            # Build was triggered but didn't complete within timeout or failed during monitoring
            if [ -n "$BUILD_NUMBER" ]; then
              echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
              if [ "$BUILD_COMPLETED" = "false" ]; then
                echo "- **Install Page**: _Build did not complete within timeout_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: â±ï¸ **TIMEOUT** - Build taking longer than expected" >> $GITHUB_STEP_SUMMARY
              else
                echo "- **Install Page**: _Build monitoring failed_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: â“ **UNKNOWN** - Check Bitrise for current status" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "- **Build Number**: _Unknown_" >> $GITHUB_STEP_SUMMARY
              echo "- **Install Page**: _Build status unknown_" >> $GITHUB_STEP_SUMMARY
              echo "- **Status**: â“ **UNKNOWN** - Build monitoring may have failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Add Bitrise build link if available
          if [ -n "${{ steps.trigger-bitrise.outputs.build_url }}" ]; then
            cat >> $GITHUB_STEP_SUMMARY <<EOF
          - **Bitrise Build**: [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})
          
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY <<EOF
          - **Bitrise Build**: _No build URL available_
          
          EOF
          fi
      
      - name: Save build results for Slack notification
        if: always()
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.wait-for-completion.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.wait-for-completion.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.get-install-url.outputs.install_url }}"
          
          # Handle cases where build wasn't triggered or completed
          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER="N/A"
            FINAL_STATUS="trigger_failed"
            BUILD_COMPLETED="false"
          elif [ -z "$FINAL_STATUS" ]; then
            FINAL_STATUS="unknown"
          fi
          
          # Create build result JSON
          BUILD_RESULT=$(cat <<EOF
          {
            "app": "${{ matrix.app }}",
            "platform": "${{ matrix.platform }}",
            "environment": "${{ matrix.environment }}",
            "build_number": "$BUILD_NUMBER",
            "status": "$FINAL_STATUS",
            "completed": "$BUILD_COMPLETED",
            "install_url": "$FINAL_INSTALL_URL",
            "bitrise_url": "${{ steps.trigger-bitrise.outputs.build_url }}"
          }
          EOF
          )
          
          # Save to artifacts
          mkdir -p build-results
          echo "$BUILD_RESULT" > "build-results/${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}.json"
      
      - name: Upload build results
        uses: actions/upload-artifact@v4
        with:
          name: build-result-${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}
          path: build-results/
          retention-days: 7
      
      - name: Report build status
        if: steps.wait-for-completion.outputs.build_failed == 'true'
        run: |
          echo "âŒ Build failed with status: ${{ steps.wait-for-completion.outputs.final_status }}"
          echo "ðŸ”— Build details: ${{ steps.trigger-bitrise.outputs.build_url }}"
          echo "ðŸ’¡ This job will fail so you can use 'Re-run failed jobs' to retry just the failed builds"
          exit 1
  
  update-release:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always() && needs.determine-build-parameters.outputs.release_exists == 'true'
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Update release with build status
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "ðŸ“ Updating release $VERSION with build information"
          
          # Get current release notes
          gh release view "$VERSION" --json body -q .body > current_notes.md
          
          # Create updated notes with build status
          cat > updated_notes.md << EOF
          $(grep -B 1000 "## ðŸ“¦ Build Status" current_notes.md | head -n -2 || cat current_notes.md)
          
          ## ðŸ“¦ Build Status
          
          âœ… **Bitrise builds triggered** at $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ### Triggered Builds:
          EOF
          
          echo '```' >> updated_notes.md
          echo "$APPS" | jq -r '.[]' | while read app; do
            APP_LOWER=$(echo "$app" | tr '[:upper:]' '[:lower:]' | tr -d '.')
            echo "âœ“ $app" >> updated_notes.md
            echo "  - ${APP_LOWER}-android-staging" >> updated_notes.md
            echo "  - ${APP_LOWER}-android-production" >> updated_notes.md
            echo "  - ${APP_LOWER}-ios-staging" >> updated_notes.md
            echo "  - ${APP_LOWER}-ios-production" >> updated_notes.md
          done
          echo '```' >> updated_notes.md
          
          cat >> updated_notes.md << EOF
          
          **Build Details:**
          - Build Workflow: [Run #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - Release Branch: \`release/$VERSION\`
          - Triggered by: @${{ github.actor }}
          - Total Builds: $(echo "$APPS" | jq -r '. | length * 4') (4 per app: android/ios Ã— staging/production)
          
          > **Note**: Check Bitrise for individual build statuses and artifacts.
          
          EOF
          
          # Add the rest of the original notes if there's content after Build Status
          if grep -A 1000 "## ðŸ“¦ Build Status" current_notes.md | tail -n +3 | grep -q "^---"; then
            echo "" >> updated_notes.md
            grep -A 1000 "^---" current_notes.md >> updated_notes.md
          else
            echo "---" >> updated_notes.md
            echo "*This release was automatically generated by GitHub Actions*" >> updated_notes.md
          fi
          
          # Update the release
          gh release edit "$VERSION" --notes-file updated_notes.md
          
          echo "âœ… Release $VERSION updated with Bitrise build status"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  summary:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Create job summary
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          RELEASE_EXISTS="${{ needs.determine-build-parameters.outputs.release_exists }}"
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ðŸš€ Bitrise Build Summary
          
          ## ðŸ“‹ Build Information
          
          | Field | Value |
          |-------|-------|
          | **Version** | \`$VERSION\` |
          | **Release Branch** | \`release/$VERSION\` |
          | **Version Source** | ${{ github.event.inputs.version_source }} |
          | **Release Exists** | $([ "$RELEASE_EXISTS" == "true" ] && echo "âœ… Yes" || echo "âš ï¸ No") |
          | **App Selection** | ${{ github.event.inputs.app_selection }} |
          | **Triggered by** | @${{ github.actor }} |
          | **Workflow Run** | #${{ github.run_number }} |
          
          ## ðŸ“¦ Bitrise Workflows Triggered
          
          | App | Platform | Environment | Workflow | Build # | Status |
          |-----|----------|-------------|----------|---------|--------|
          EOF
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            APP_LOWER=$(echo "$app" | tr '[:upper:]' '[:lower:]' | tr -d '.')
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                
                if [ -f "$BUILD_FILE" ]; then
                  BUILD_DATA=$(cat "$BUILD_FILE")
                  BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
                  INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
                  STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
                  COMPLETED=$(echo "$BUILD_DATA" | jq -r '.completed')
                  
                  # Format build number with hyperlink if available (Android only)
                  if [ "$platform" = "android" ] && [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                    BUILD_DISPLAY="[#$BUILD_NUM]($INSTALL_URL)"
                  else
                    BUILD_DISPLAY="\`#$BUILD_NUM\`"
                  fi
                  
                  # Format status
                  case "$STATUS" in
                    "success") STATUS_DISPLAY="âœ… SUCCESS" ;;
                    "error") STATUS_DISPLAY="âŒ FAILED" ;;
                    "aborted") STATUS_DISPLAY="âš ï¸ ABORTED" ;;
                    "timeout") STATUS_DISPLAY="â±ï¸ TIMEOUT" ;;
                    *) STATUS_DISPLAY="â“ $STATUS" ;;
                  esac
                  
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | $BUILD_DISPLAY | $STATUS_DISPLAY |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | _No data_ | â“ Unknown |" >> $GITHUB_STEP_SUMMARY
                fi
              done
            done
          done
          
          # Calculate total builds and overall status
          TOTAL_APPS=$(echo "$APPS" | jq -r '. | length')
          TOTAL_BUILDS=$((TOTAL_APPS * 4))
          
          # Count build results by status
          SUCCESS_COUNT=0
          FAILED_COUNT=0
          ABORTED_COUNT=0
          TIMEOUT_COUNT=0
          UNKNOWN_COUNT=0
          
          for app in $(echo "$APPS" | jq -r '.[]'); do
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                if [ -f "$BUILD_FILE" ]; then
                  STATUS=$(cat "$BUILD_FILE" | jq -r '.status')
                  case "$STATUS" in
                    "success") SUCCESS_COUNT=$((SUCCESS_COUNT + 1)) ;;
                    "error") FAILED_COUNT=$((FAILED_COUNT + 1)) ;;
                    "aborted") ABORTED_COUNT=$((ABORTED_COUNT + 1)) ;;
                    "timeout") TIMEOUT_COUNT=$((TIMEOUT_COUNT + 1)) ;;
                    *) UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1)) ;;
                  esac
                else
                  UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1))
                fi
              done
            done
          done
          
          # Determine overall workflow status
          if [ $FAILED_COUNT -gt 0 ] || [ $ABORTED_COUNT -gt 0 ] || [ $TIMEOUT_COUNT -gt 0 ]; then
            if [ $SUCCESS_COUNT -gt 0 ]; then
              OVERALL_STATUS="âš ï¸ **PARTIAL SUCCESS** - Some builds failed but workflow continued"
            else
              OVERALL_STATUS="âŒ **FAILED** - All builds failed"
            fi
          elif [ $SUCCESS_COUNT -eq $TOTAL_BUILDS ]; then
            OVERALL_STATUS="âœ… **SUCCESS** - All builds completed successfully"
          else
            OVERALL_STATUS="ðŸ”„ **IN PROGRESS** - Some builds still processing"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          
          ## ðŸ“Š Summary
          
          - **Overall Status**: $OVERALL_STATUS
          - **Total Apps**: $TOTAL_APPS
          - **Builds per App**: 4 (2 platforms Ã— 2 environments)
          - **Total Builds Triggered**: $TOTAL_BUILDS
          - **Successful**: $SUCCESS_COUNT
          - **Failed**: $FAILED_COUNT
          - **Aborted**: $ABORTED_COUNT
          - **Timeout**: $TIMEOUT_COUNT
          - **Unknown/Pending**: $UNKNOWN_COUNT
          
          ## ðŸ”— Links
          
          EOF
          
          if [ "$RELEASE_EXISTS" == "true" ]; then
            echo "- [View Release](https://github.com/${{ github.repository }}/releases/tag/$VERSION)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- âš ï¸ No release found for version $VERSION" >> $GITHUB_STEP_SUMMARY
            echo "- [Create Release](https://github.com/${{ github.repository }}/actions/workflows/create-release-version.yml)" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          - [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Bitrise Dashboard](https://app.bitrise.io/dashboard)
          
          ## âš ï¸ Important Notes
          
          1. **Build Numbers**: Individual Bitrise build numbers are shown in the build details above
          2. **Install Pages**: Public install page links are available in the build details above (after build completion)
          3. **Check Bitrise** for individual build statuses and download artifacts
          4. **Release Branch**: All builds are from \`release/$VERSION\`
          5. **Workflow Naming**: Follows pattern \`{app}-{platform}-{environment}\`
          
          ---
          *Builds triggered at $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF
  
  slack-notification:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Prepare Slack message
        id: slack-message
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "ðŸ“± Preparing Slack message for release $VERSION"
                   
          # Process build results by app
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "Processing app: $app"
            
            # Process builds for this app
            STAGING_ANDROID="N/A"
            STAGING_IOS="N/A"
            PROD_ANDROID="N/A"
            PROD_IOS="N/A"
            
            # Check for Android staging - with install page links
            if [ -f "build-results/${app}-android-staging.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-android-staging.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              BITRISE_URL=$(echo "$BUILD_DATA" | jq -r '.bitrise_url // empty')
              
              if [ "$STATUS" != "success" ]; then
                # Build failed - link to Bitrise build with failure indicator
                if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                  STAGING_ANDROID="<$BITRISE_URL|$BUILD_NUM (failed)>"
                else
                  STAGING_ANDROID="$BUILD_NUM (failed)"
                fi
              elif [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                STAGING_ANDROID="<$INSTALL_URL|$BUILD_NUM>"
              else
                STAGING_ANDROID="$BUILD_NUM"
              fi
            fi
            
            # Check for iOS staging - no install page expected
            if [ -f "build-results/${app}-ios-staging.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-ios-staging.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              BITRISE_URL=$(echo "$BUILD_DATA" | jq -r '.bitrise_url // empty')
              
              if [ "$STATUS" != "success" ]; then
                # Build failed - link to Bitrise build with failure indicator
                if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                  STAGING_IOS="<$BITRISE_URL|$BUILD_NUM (failed)>"
                else
                  STAGING_IOS="$BUILD_NUM (failed)"
                fi
              else
                # iOS builds don't need install URLs
                STAGING_IOS="$BUILD_NUM"
              fi
            fi
            
            # Check for Android production - with install page links
            if [ -f "build-results/${app}-android-production.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-android-production.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              BITRISE_URL=$(echo "$BUILD_DATA" | jq -r '.bitrise_url // empty')
              
              if [ "$STATUS" != "success" ]; then
                # Build failed - link to Bitrise build with failure indicator
                if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                  PROD_ANDROID="<$BITRISE_URL|$BUILD_NUM (failed)>"
                else
                  PROD_ANDROID="$BUILD_NUM (failed)"
                fi
              elif [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                PROD_ANDROID="<$INSTALL_URL|$BUILD_NUM>"
              else
                PROD_ANDROID="$BUILD_NUM"
              fi
            fi
            
            # Check for iOS production - no install page expected
            if [ -f "build-results/${app}-ios-production.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-ios-production.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              BITRISE_URL=$(echo "$BUILD_DATA" | jq -r '.bitrise_url // empty')
              
              if [ "$STATUS" != "success" ]; then
                # Build failed - link to Bitrise build with failure indicator
                if [ -n "$BITRISE_URL" ] && [ "$BITRISE_URL" != "null" ] && [ "$BITRISE_URL" != "empty" ]; then
                  PROD_IOS="<$BITRISE_URL|$BUILD_NUM (failed)>"
                else
                  PROD_IOS="$BUILD_NUM (failed)"
                fi
              else
                # iOS builds don't need install URLs
                PROD_IOS="$BUILD_NUM"
              fi
            fi
            
            # Append to message file
            cat >> slack_message.txt << EOF
          â—‹ *$app*
            â–  *Staging:* :android: $STAGING_ANDROID  :appleinc: $STAGING_IOS
            â–  *Production:* :android: $PROD_ANDROID  :appleinc: $PROD_IOS
          EOF
          
          done
          
          # Add footer
          cat >> slack_message.txt << EOF
          
          :rocket: *Release:* <${{ github.server_url }}/${{ github.repository }}/releases/tag/$VERSION|$VERSION>
          :github: *Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run #${{ github.run_number }}>
          EOF
          
          echo "Final Slack message:"
          cat slack_message.txt
      
      - name: Send Slack notification
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "âš ï¸ SLACK_WEBHOOK_URL not configured - skipping Slack notification"
            exit 0
          fi
          
          echo "ðŸ“¤ Sending Slack notification..."
          
          # Read the message and escape for JSON
          MESSAGE_CONTENT=$(cat slack_message.txt | jq -Rs .)
          
          # Determine channel (use override if specified, otherwise webhook default)
          CHANNEL_OVERRIDE=""
          if [ -n "$SLACK_CHANNEL" ]; then
            CHANNEL_OVERRIDE=",\"channel\": \"$SLACK_CHANNEL\""
            echo "ðŸŽ¯ Overriding channel to: $SLACK_CHANNEL"
          else
            echo "ðŸ“ Using webhook default channel"
          fi
          
          # Create JSON payload with optional channel override
          PAYLOAD=$(cat << EOF
          {
            "text": "ðŸš€ Build Results for Release ${{ needs.determine-build-parameters.outputs.version }}"$CHANNEL_OVERRIDE,
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": $MESSAGE_CONTENT
                }
              }
            ]
          }
          EOF
          )
          
          echo "Payload preview:"
          echo "$PAYLOAD" | jq .
          
          # Send to Slack
          RESPONSE=$(curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL")
          
          if [ "$RESPONSE" = "ok" ]; then
            echo "âœ… Slack notification sent successfully!"
          else
            echo "âŒ Failed to send Slack notification. Response: $RESPONSE"
            exit 1
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL }}
  
  cancel-bitrise-builds:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: cancelled()
    
    steps:
      - name: Download build slug artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-slug-*
          merge-multiple: true
          path: build-slugs/
        continue-on-error: true
      
      - name: Cancel Bitrise builds
        env:
          BITRISE_APP_ID: ${{ secrets.BITRISE_PROJECT_SLUG }}
          BITRISE_ACCESS_TOKEN: ${{ secrets.BITRISE_ACCESS_TOKEN }}
        run: |
          echo "ðŸš« Workflow cancelled - attempting to cancel Bitrise builds..."
          
          CANCELLED_COUNT=0
          TOTAL_BUILDS=0
          
          if [ ! -d "build-slugs" ]; then
            echo "âš ï¸ No build slug artifacts found - builds may not have been triggered yet"
            exit 0
          fi
          
          # Process each build slug file
          for build_file in build-slugs/*.json; do
            if [ ! -f "$build_file" ]; then
              echo "âš ï¸ No build slug files found"
              continue
            fi
            
            TOTAL_BUILDS=$((TOTAL_BUILDS + 1))
            
            # Extract build information
            BUILD_DATA=$(cat "$build_file")
            BUILD_SLUG=$(echo "$BUILD_DATA" | jq -r '.build_slug')
            APP=$(echo "$BUILD_DATA" | jq -r '.app')
            PLATFORM=$(echo "$BUILD_DATA" | jq -r '.platform')
            ENVIRONMENT=$(echo "$BUILD_DATA" | jq -r '.environment')
            BUILD_URL=$(echo "$BUILD_DATA" | jq -r '.build_url')
            
            echo ""
            echo "ðŸ“± Processing: $APP ($PLATFORM/$ENVIRONMENT)"
            echo "ðŸ”— Build Slug: $BUILD_SLUG"
            echo "ðŸŒ Build URL: $BUILD_URL"
            
            # Check current build status first
            echo "ðŸ” Checking current build status..."
            STATUS_RESPONSE=$(curl -s -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
              "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds/${BUILD_SLUG}")
            
            if ! echo "$STATUS_RESPONSE" | jq empty 2>/dev/null; then
              echo "âŒ Failed to get build status (invalid JSON response)"
              continue
            fi
            
            BUILD_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.data.status_text // "unknown"')
            FINISHED_AT=$(echo "$STATUS_RESPONSE" | jq -r '.data.finished_at // null')
            
            echo "ðŸ“Š Current Status: $BUILD_STATUS"
            
            # Skip if build is already finished
            if [ "$BUILD_STATUS" = "success" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ] || [ "$FINISHED_AT" != "null" ]; then
              echo "âœ… Build already finished ($BUILD_STATUS) - skipping cancellation"
              continue
            fi
            
            # Attempt to cancel the build
            echo "ðŸš« Attempting to cancel build..."
            CANCEL_RESPONSE=$(curl -s -X POST -w "HTTPSTATUS:%{http_code}" \
              -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
              -H "Content-Type: application/json" \
              -d '{"abort_reason": "GitHub Actions workflow was cancelled"}' \
              "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds/${BUILD_SLUG}/abort")
            
            # Extract HTTP status and response
            HTTP_STATUS=$(echo "$CANCEL_RESPONSE" | grep -o 'HTTPSTATUS:[0-9]*' | cut -d: -f2)
            CANCEL_DATA=$(echo "$CANCEL_RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
            
            echo "ðŸŒ HTTP Status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Successfully cancelled Bitrise build for $APP ($PLATFORM/$ENVIRONMENT)"
              CANCELLED_COUNT=$((CANCELLED_COUNT + 1))
            elif [ "$HTTP_STATUS" = "400" ]; then
              echo "âš ï¸ Build cannot be cancelled (likely already finished or not running)"
            elif [ "$HTTP_STATUS" = "404" ]; then
              echo "âŒ Build not found - may have been already cancelled or removed"
            else
              echo "âŒ Failed to cancel build (HTTP $HTTP_STATUS)"
              echo "Response: $CANCEL_DATA"
            fi
          done
          
          echo ""
          echo "ðŸ“Š Cancellation Summary:"
          echo "  Total builds processed: $TOTAL_BUILDS"
          echo "  Successfully cancelled: $CANCELLED_COUNT"
          echo "  Skipped (already finished): $((TOTAL_BUILDS - CANCELLED_COUNT))"
          
          if [ $CANCELLED_COUNT -gt 0 ]; then
            echo "âœ… Cancelled $CANCELLED_COUNT Bitrise build(s) due to workflow cancellation"
          else
            echo "â„¹ï¸ No running builds found to cancel"
          fi
      
      - name: Create cancellation summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ðŸš« Workflow Cancelled - Bitrise Build Cleanup
          
          ## ðŸ“‹ Cancellation Information
          
          | Field | Value |
          |-------|-------|
          | **Cancelled At** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |
          | **Version** | \`${{ needs.determine-build-parameters.outputs.version }}\` |
          | **Triggered by** | @${{ github.actor }} |
          | **Workflow Run** | #${{ github.run_number }} |
          
          ## ðŸš« Build Cancellation Status
          
          The workflow was cancelled and we attempted to cancel any running Bitrise builds to prevent unnecessary resource usage.
          
          **Note**: 
          - Builds that were already completed (success/error/aborted) were left as-is
          - Only running or queued builds were cancelled
          - Check the job logs above for detailed cancellation results
          
          ## ðŸ”— Links
          
          - [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Bitrise Dashboard](https://app.bitrise.io/dashboard)
          
          ---
          *Cancellation processed at $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF