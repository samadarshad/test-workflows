name: Build Apps

run-name: "Build Apps: ${{ github.event.inputs.version_source == 'latest' && 'Latest Release' || github.event.inputs.manual_version }} - ${{ github.event.inputs.app_selection == 'all' && 'All apps' || github.event.inputs.specific_app }}"

on:
  workflow_dispatch:
    inputs:
      version_source:
        description: 'Version source'
        required: true
        type: choice
        options:
          - latest
          - manual
        default: latest
      
      manual_version:
        description: 'Manual version (e.g., v3.28.0) - only used if version_source is "manual"'
        required: false
        type: string
      
      app_selection:
        description: 'Apps to build'
        required: true
        type: choice
        options:
          - all
          - specific
        default: all
      
      specific_app:
        description: 'Specific app name (only used if app_selection is "specific")'
        required: false
        type: choice
        options:
          - ev.energy
          - NGMA
          - NGNY
          - SVCE
          - MCE
          - ANWB
        default: ev.energy

jobs:
  determine-build-parameters:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.determine-version.outputs.version }}
      apps: ${{ steps.determine-apps.outputs.apps }}
      release_exists: ${{ steps.check-release.outputs.exists }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine version to build
        id: determine-version
        run: |
          if [ "${{ github.event.inputs.version_source }}" == "latest" ]; then
            # Get the latest release tag
            VERSION=$(gh release list --limit 1 --json tagName -q '.[0].tagName')
            
            if [ -z "$VERSION" ]; then
              echo "Error: No releases found. Please create a release first using the 'Create Release Version' workflow."
              exit 1
            fi
            
            echo "Using latest release: $VERSION"
          else
            # Use manual version
            VERSION="${{ github.event.inputs.manual_version }}"
            
            # Validate format
            if ! echo "$VERSION" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)*$' > /dev/null; then
              echo "Error: Invalid version format. Expected format: vX.Y.Z or vX.Y.Z-suffix (e.g., v3.28.0 or v3.29.0-abc)"
              exit 1
            fi
            
            echo "Using manual version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Display version banner
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë     BUILD VERSION: $VERSION           "
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if release exists
        id: check-release
        run: |
          VERSION="${{ steps.determine-version.outputs.version }}"
          
          # Check if the release exists
          if gh release view "$VERSION" > /dev/null 2>&1; then
            echo "‚úÖ Release $VERSION exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            
            # Get release URL for reference
            RELEASE_URL=$(gh release view "$VERSION" --json url -q .url)
            echo "Release URL: $RELEASE_URL"
          else
            echo "‚ö†Ô∏è Warning: Release $VERSION does not exist yet"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Determine apps to build
        id: determine-apps
        run: |
          if [ "${{ github.event.inputs.app_selection }}" == "all" ]; then
            APPS='["ev.energy", "NGMA", "NGNY", "SVCE", "MCE", "ANWB"]'
            echo "Building all apps"
          else
            APPS='["${{ github.event.inputs.specific_app }}"]'
            echo "Building specific app: ${{ github.event.inputs.specific_app }}"
          fi
          
          echo "apps=$APPS" >> $GITHUB_OUTPUT
      
      - name: Display build information
        run: |
          echo "========================================="
          echo "üì¶ BUILD CONFIGURATION"
          echo "========================================="
          echo "Version: ${{ steps.determine-version.outputs.version }}"
          echo "Release Exists: ${{ steps.check-release.outputs.exists }}"
          echo "Apps to build: ${{ steps.determine-apps.outputs.apps }}"
          echo "========================================="
          
          # Parse and display apps in a readable format
          APPS='${{ steps.determine-apps.outputs.apps }}'
          echo ""
          echo "Apps list:"
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "  - $app"
          done
          echo ""
          echo "========================================="
  
  build-apps:
    needs: determine-build-parameters
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.determine-build-parameters.outputs.apps) }}
        platform: [android, ios]
        environment: [staging, production]
    
    steps:
      - name: Prepare build configuration
        id: build-config
        run: |
          # Convert app name to lowercase and remove dots for workflow name
          APP_NAME="${{ matrix.app }}"
          APP_NAME_LOWER=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          APP_NAME_CLEAN=$(echo "$APP_NAME_LOWER" | tr -d '.')
          
          # Construct workflow name
          WORKFLOW_NAME="${APP_NAME_CLEAN}-${{ matrix.platform }}-${{ matrix.environment }}"
          
          # Release branch name
          BRANCH_NAME="release/${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "app_name_clean=$APP_NAME_CLEAN" >> $GITHUB_OUTPUT
          echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          echo "üì± Build Configuration:"
          echo "  App: ${{ matrix.app }}"
          echo "  Platform: ${{ matrix.platform }}"
          echo "  Environment: ${{ matrix.environment }}"
          echo "  Workflow: $WORKFLOW_NAME"
          echo "  Branch: $BRANCH_NAME"
          echo "  Version: ${{ needs.determine-build-parameters.outputs.version }}"
      
      - name: Trigger Bitrise build
        id: trigger-bitrise
        env:
          BITRISE_APP_ID: ${{ secrets.BITRISE_PROJECT_SLUG }}
          BITRISE_ACCESS_TOKEN: ${{ secrets.BITRISE_ACCESS_TOKEN }}
        run: |
          WORKFLOW_NAME="${{ steps.build-config.outputs.workflow_name }}"
          BRANCH_NAME="${{ steps.build-config.outputs.branch_name }}"
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "üöÄ Triggering Bitrise build for $WORKFLOW_NAME"
          
          # Trigger Bitrise build using personal access token
          RESPONSE=$(curl -X POST "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds" \
            -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{
              \"hook_info\": {
                \"type\": \"bitrise\"
              },
              \"build_params\": {
                \"branch\": \"${BRANCH_NAME}\",
                \"workflow_id\": \"${WORKFLOW_NAME}\",
                \"environments\": [
                  {
                    \"mapped_to\": \"RELEASE_VERSION\",
                    \"value\": \"${VERSION}\",
                    \"is_expand\": true
                  },
                  {
                    \"mapped_to\": \"TRIGGERED_BY\",
                    \"value\": \"GitHub Actions - ${{ github.actor }}\",
                    \"is_expand\": true
                  }
                ],
                \"commit_message\": \"Build ${VERSION} - ${{ matrix.app }} (${{ matrix.platform }}/${{ matrix.environment }})\"
              }
            }")
          
          # Debug: Show full response structure
          echo "üîç Full Bitrise API Response:"
          echo "$RESPONSE" | jq .
          
          # Extract build URL, status, build number, and public install page URL
          BUILD_URL=$(echo "$RESPONSE" | jq -r '.build_url // empty')
          BUILD_SLUG=$(echo "$RESPONSE" | jq -r '.build_slug // empty')
          BUILD_NUMBER=$(echo "$RESPONSE" | jq -r '.build_number // empty')
          PUBLIC_INSTALL_PAGE_URL=$(echo "$RESPONSE" | jq -r '.public_install_page_url // empty')
          STATUS=$(echo "$RESPONSE" | jq -r '.status // empty')
          
          if [ -z "$BUILD_URL" ] || [ "$STATUS" == "error" ]; then
            echo "‚ùå Failed to trigger Bitrise build"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          echo "‚úÖ Bitrise build triggered successfully"
          echo "Build URL: $BUILD_URL"
          echo "Build Slug: $BUILD_SLUG"
          echo "Build Number: $BUILD_NUMBER"
          echo "Public Install Page: $PUBLIC_INSTALL_PAGE_URL"
          
          # Check available fields for install page
          echo "üîç Checking for install page related fields:"
          echo "$RESPONSE" | jq 'keys[]' | grep -i install || echo "No install-related keys found"
          
          echo "build_url=$BUILD_URL" >> $GITHUB_OUTPUT
          echo "build_slug=$BUILD_SLUG" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "public_install_page_url=$PUBLIC_INSTALL_PAGE_URL" >> $GITHUB_OUTPUT
      
      - name: Save build slug for cancellation
        run: |
          BUILD_SLUG="${{ steps.trigger-bitrise.outputs.build_slug }}"
          
          # Create build slug info for cancellation purposes
          BUILD_INFO=$(cat <<EOF
          {
            "app": "${{ matrix.app }}",
            "platform": "${{ matrix.platform }}",
            "environment": "${{ matrix.environment }}",
            "build_slug": "$BUILD_SLUG",
            "build_url": "${{ steps.trigger-bitrise.outputs.build_url }}",
            "workflow_name": "${{ steps.build-config.outputs.workflow_name }}",
            "triggered_at": "$(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          }
          EOF
          )
          
          # Save to cancellation artifacts directory
          mkdir -p build-slugs
          echo "$BUILD_INFO" > "build-slugs/${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}.json"
      
      - name: Upload build slug for cancellation
        uses: actions/upload-artifact@v4
        with:
          name: build-slug-${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}
          path: build-slugs/
          retention-days: 1
      
      - name: Wait for Bitrise build completion
        id: wait-for-completion
        run: |
          BUILD_SLUG="${{ steps.trigger-bitrise.outputs.build_slug }}"
          MAX_WAIT_TIME=3600  # 1 hour maximum wait time
          POLL_INTERVAL=30    # Check every 30 seconds
          elapsed_time=0
          
          echo "‚è≥ Waiting for Bitrise build to complete..."
          echo "Build Slug: $BUILD_SLUG"
          echo "Maximum wait time: ${MAX_WAIT_TIME} seconds"
          echo "API URL: https://api.bitrise.io/v0.1/apps/${{ secrets.BITRISE_PROJECT_SLUG }}/builds/${BUILD_SLUG}"
          
          while [ $elapsed_time -lt $MAX_WAIT_TIME ]; do
            # Get build status with HTTP status code
            HTTP_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -H "Authorization: token ${{ secrets.BITRISE_ACCESS_TOKEN }}" \
              "https://api.bitrise.io/v0.1/apps/${{ secrets.BITRISE_PROJECT_SLUG }}/builds/${BUILD_SLUG}")
            
            # Extract HTTP status and body
            HTTP_STATUS=$(echo "$HTTP_RESPONSE" | grep -o 'HTTPSTATUS:[0-9]*' | cut -d: -f2)
            STATUS_RESPONSE=$(echo "$HTTP_RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
            
            echo "HTTP Status: $HTTP_STATUS"
            
            # Check HTTP status first
            if [ "$HTTP_STATUS" != "200" ]; then
              echo "‚ö†Ô∏è HTTP $HTTP_STATUS from Bitrise API (elapsed: ${elapsed_time}s)"
              echo "Response body: $STATUS_RESPONSE"
              
              if [ "$HTTP_STATUS" = "404" ]; then
                echo "‚ùå Build not found (404) - build slug may be invalid"
                echo "final_status=not_found" >> $GITHUB_OUTPUT
                echo "build_completed=false" >> $GITHUB_OUTPUT
                exit 1
              elif [ "$HTTP_STATUS" = "401" ]; then
                echo "‚ùå Unauthorized (401) - check BITRISE_ACCESS_TOKEN"
                echo "final_status=unauthorized" >> $GITHUB_OUTPUT
                echo "build_completed=false" >> $GITHUB_OUTPUT
                exit 1
              fi
              
              # For other HTTP errors, wait and retry
              sleep $POLL_INTERVAL
              elapsed_time=$((elapsed_time + POLL_INTERVAL))
              continue
            fi
            
            # Check if response is valid JSON
            if ! echo "$STATUS_RESPONSE" | jq empty 2>/dev/null; then
              echo "‚ö†Ô∏è Invalid JSON response from Bitrise API (elapsed: ${elapsed_time}s)"
              echo "Response: $STATUS_RESPONSE"
              
              # Wait and retry for invalid JSON
              sleep $POLL_INTERVAL
              elapsed_time=$((elapsed_time + POLL_INTERVAL))
              continue
            fi
            
            BUILD_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.data.status_text // "unknown"')
            FINISHED_AT=$(echo "$STATUS_RESPONSE" | jq -r '.data.finished_at // null')
            
            echo "Build Status: $BUILD_STATUS (elapsed: ${elapsed_time}s)"
            
            # Check if build is finished (success or failed)
            if [ "$BUILD_STATUS" = "success" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ] || [ "$FINISHED_AT" != "null" ]; then
              echo "‚úÖ Build finished with status: $BUILD_STATUS"
              
              # Debug: Show full build completion response (only for Android)
              if [ "${{ matrix.platform }}" = "android" ]; then
                echo "üîç Full build completion response:"
                echo "$STATUS_RESPONSE" | jq .data
              fi
              
              echo "final_status=$BUILD_STATUS" >> $GITHUB_OUTPUT
              echo "build_completed=true" >> $GITHUB_OUTPUT
              
              # Note build failure but don't exit - let summary steps run
              if [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ]; then
                echo "‚ùå Build failed with status: $BUILD_STATUS"
                echo "build_failed=true" >> $GITHUB_OUTPUT
              else
                echo "build_failed=false" >> $GITHUB_OUTPUT
              fi
              
              break
            fi
            
            # Wait before next poll
            sleep $POLL_INTERVAL
            elapsed_time=$((elapsed_time + POLL_INTERVAL))
          done
          
          # Check if we timed out
          if [ $elapsed_time -ge $MAX_WAIT_TIME ]; then
            echo "‚ö†Ô∏è Build did not complete within ${MAX_WAIT_TIME} seconds"
            echo "final_status=timeout" >> $GITHUB_OUTPUT
            echo "build_completed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Get public install page URL
        id: get-install-url
        if: matrix.platform == 'android' && steps.wait-for-completion.outputs.build_completed == 'true' && steps.wait-for-completion.outputs.final_status == 'success'
        run: |
          echo "ü§ñ Android build successful - using Release Management API to get public install page URL..."
          
          # Poll for install page URL using Release Management API
          INSTALL_PAGE_WAIT_TIME=180  # 3 minutes max wait for install page
          INSTALL_PAGE_POLL_INTERVAL=15  # Check every 15 seconds
          install_page_elapsed=0
          
          # Extract version and build number for Release Management API search
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          VERSION_CLEAN=$(echo "$VERSION" | sed 's/^v//')  # Remove 'v' prefix
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          
          echo "üîç Searching Release Management API with:"
          echo "  Version: $VERSION_CLEAN"
          echo "  Build Number: $BUILD_NUMBER"
          echo "  App: ${{ matrix.app }}"
          
          FINAL_PUBLIC_INSTALL_URL=""
          
          while [ $install_page_elapsed -lt $INSTALL_PAGE_WAIT_TIME ]; do
            echo "üîç Checking Release Management API for install page URL (elapsed: ${install_page_elapsed}s)..."
            
            # Use Release Management API to find installable artifacts
            # Note: BITRISE_CONNECTED_APP_ID should be set as a secret for the connected app ID
            CONNECTED_APP_ID="${{ secrets.BITRISE_CONNECTED_APP_ID }}"
            
            if [ -n "$CONNECTED_APP_ID" ]; then
              # Search by build number first
              RELEASE_MGMT_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.BITRISE_ACCESS_TOKEN }}" \
                "https://api.bitrise.io/release-management/v1/connected-apps/${CONNECTED_APP_ID}/installable-artifacts?items_per_page=20&page=1&search=${BUILD_NUMBER}&version=${VERSION_CLEAN}")
              
              echo "üîç Release Management API response:"
              echo "$RELEASE_MGMT_RESPONSE" | jq . || echo "Invalid JSON response"
              
              if echo "$RELEASE_MGMT_RESPONSE" | jq empty 2>/dev/null; then
                # Check if we got any items
                ITEM_COUNT=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r '.count // 0')
                echo "Found $ITEM_COUNT installable artifact(s)"
                
                if [ "$ITEM_COUNT" -gt 0 ]; then
                  # Look for matching artifact by workflow name (most precise match)
                  WORKFLOW_NAME="${{ steps.build-config.outputs.workflow_name }}"
                  echo "üéØ Looking for workflow: $WORKFLOW_NAME"
                  
                  FINAL_PUBLIC_INSTALL_URL=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg workflow "$WORKFLOW_NAME" \
                    '.items[] | select(.workflow == $workflow) | .public_install_page_url // empty' | head -1)
                  
                  # If no workflow match, try matching by app name and platform
                  if [ -z "$FINAL_PUBLIC_INSTALL_URL" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "empty" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "null" ]; then
                    echo "üéØ Looking for app: ${{ matrix.app }}, platform: android"
                    FINAL_PUBLIC_INSTALL_URL=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg app "${{ matrix.app }}" \
                      '.items[] | select(.app_name | test($app; "i")) | select(.platform == "android") | .public_install_page_url // empty' | head -1)
                  fi
                  
                  # If still no match, try any Android APK from this build
                  if [ -z "$FINAL_PUBLIC_INSTALL_URL" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "empty" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "null" ]; then
                    echo "üéØ Looking for any Android APK with build number: $BUILD_NUMBER"
                    FINAL_PUBLIC_INSTALL_URL=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg build_num "$BUILD_NUMBER" \
                      '.items[] | select(.build_number == $build_num) | select(.platform == "android") | .public_install_page_url // empty' | head -1)
                  fi
                  
                  # Check if we found a valid URL
                  if [ -n "$FINAL_PUBLIC_INSTALL_URL" ] && [ "$FINAL_PUBLIC_INSTALL_URL" != "empty" ] && [ "$FINAL_PUBLIC_INSTALL_URL" != "null" ]; then
                    echo "‚úÖ Found install page URL from Release Management API: $FINAL_PUBLIC_INSTALL_URL"
                    
                    # Show which artifact we matched
                    MATCHED_ARTIFACT=$(echo "$RELEASE_MGMT_RESPONSE" | jq -r --arg url "$FINAL_PUBLIC_INSTALL_URL" \
                      '.items[] | select(.public_install_page_url == $url) | "\(.app_name) - \(.workflow) - \(.filename)"')
                    echo "üì± Matched artifact: $MATCHED_ARTIFACT"
                    break
                  else
                    echo "‚ö†Ô∏è No public install page URL found in Release Management response"
                  fi
                else
                  echo "‚ö†Ô∏è No installable artifacts found for build $BUILD_NUMBER, version $VERSION_CLEAN"
                fi
              fi
            else
              echo "‚ö†Ô∏è BITRISE_CONNECTED_APP_ID not set - Release Management API unavailable"
              echo "üí° Please set BITRISE_CONNECTED_APP_ID secret to use Release Management API"
            fi
            
            echo "‚è≥ Install page URL not ready yet, waiting ${INSTALL_PAGE_POLL_INTERVAL}s..."
            sleep $INSTALL_PAGE_POLL_INTERVAL
            install_page_elapsed=$((install_page_elapsed + INSTALL_PAGE_POLL_INTERVAL))
          done
          
          # Check if we timed out waiting for install page
          if [ $install_page_elapsed -ge $INSTALL_PAGE_WAIT_TIME ] && ([ -z "$FINAL_PUBLIC_INSTALL_URL" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "empty" ] || [ "$FINAL_PUBLIC_INSTALL_URL" = "null" ]); then
            echo "‚ö†Ô∏è Timed out waiting for install page URL after ${INSTALL_PAGE_WAIT_TIME}s"
            echo "üéØ Note: Install page may still become available later - check Bitrise dashboard"
            echo "üí° Tip: Ensure BITRISE_CONNECTED_APP_ID secret is set for Release Management API access"
            FINAL_PUBLIC_INSTALL_URL=""
          fi
          
          echo "Final Public Install Page: $FINAL_PUBLIC_INSTALL_URL"
          echo "install_url=$FINAL_PUBLIC_INSTALL_URL" >> $GITHUB_OUTPUT
      
      - name: Create build summary entry
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.wait-for-completion.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.wait-for-completion.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.get-install-url.outputs.install_url }}"
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ### ${{ matrix.app }} - ${{ matrix.platform }}/${{ matrix.environment }}
          - **Workflow**: \`${{ steps.build-config.outputs.workflow_name }}\`
          - **Branch**: \`${{ steps.build-config.outputs.branch_name }}\`
          EOF
          
          # Show final build status and install links
          if [ "$BUILD_COMPLETED" = "true" ]; then
            case "$FINAL_STATUS" in
              "success")
                if [ "${{ matrix.platform }}" = "android" ]; then
                  # Android builds should have install pages
                  if [ -n "$FINAL_INSTALL_URL" ] && [ "$FINAL_INSTALL_URL" != "null" ] && [ "$FINAL_INSTALL_URL" != "empty" ]; then
                    echo "- **Build Number**: [#$BUILD_NUMBER]($FINAL_INSTALL_URL) üì±" >> $GITHUB_STEP_SUMMARY
                    echo "- **Install Page**: [Download APK]($FINAL_INSTALL_URL) ü§ñ" >> $GITHUB_STEP_SUMMARY
                    echo "- **Status**: ‚úÖ **SUCCESS** - Ready to install!" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                    echo "- **Install Page**: _No install page available_" >> $GITHUB_STEP_SUMMARY
                    echo "- **Status**: ‚úÖ **SUCCESS** - Check Bitrise for APK" >> $GITHUB_STEP_SUMMARY
                  fi
                else
                  # iOS builds don't need install pages
                  echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                  echo "- **Install Page**: _iOS build (TestFlight/App Store)_ üçé" >> $GITHUB_STEP_SUMMARY
                  echo "- **Status**: ‚úÖ **SUCCESS** - Check Bitrise for artifacts" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              "error")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build failed - no install page available_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ‚ùå **FAILED** - [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})" >> $GITHUB_STEP_SUMMARY
                ;;
              "aborted")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build was aborted_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ‚ö†Ô∏è **ABORTED** - [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})" >> $GITHUB_STEP_SUMMARY
                ;;
              "timeout")
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Build still in progress - check Bitrise_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ‚è±Ô∏è **TIMEOUT** - Build taking longer than expected" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
                echo "- **Install Page**: _Status: $FINAL_STATUS_" >> $GITHUB_STEP_SUMMARY
                echo "- **Status**: ‚ùì **$FINAL_STATUS**" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            echo "- **Build Number**: \`#$BUILD_NUMBER\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Install Page**: _Build did not complete within timeout_" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ‚è±Ô∏è **TIMEOUT**" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          - **Bitrise Build**: [View Build Details](${{ steps.trigger-bitrise.outputs.build_url }})
          
          EOF
      
      - name: Save build results for Slack notification
        run: |
          BUILD_NUMBER="${{ steps.trigger-bitrise.outputs.build_number }}"
          BUILD_COMPLETED="${{ steps.wait-for-completion.outputs.build_completed }}"
          FINAL_STATUS="${{ steps.wait-for-completion.outputs.final_status }}"
          FINAL_INSTALL_URL="${{ steps.get-install-url.outputs.install_url }}"
          
          # Create build result JSON
          BUILD_RESULT=$(cat <<EOF
          {
            "app": "${{ matrix.app }}",
            "platform": "${{ matrix.platform }}",
            "environment": "${{ matrix.environment }}",
            "build_number": "$BUILD_NUMBER",
            "status": "$FINAL_STATUS",
            "completed": "$BUILD_COMPLETED",
            "install_url": "$FINAL_INSTALL_URL",
            "bitrise_url": "${{ steps.trigger-bitrise.outputs.build_url }}"
          }
          EOF
          )
          
          # Save to artifacts
          mkdir -p build-results
          echo "$BUILD_RESULT" > "build-results/${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}.json"
      
      - name: Upload build results
        uses: actions/upload-artifact@v4
        with:
          name: build-result-${{ matrix.app }}-${{ matrix.platform }}-${{ matrix.environment }}
          path: build-results/
          retention-days: 7
      
      - name: Report build status
        if: steps.wait-for-completion.outputs.build_failed == 'true'
        run: |
          echo "‚ùå Build failed with status: ${{ steps.wait-for-completion.outputs.final_status }}"
          echo "üîó Build details: ${{ steps.trigger-bitrise.outputs.build_url }}"
          echo "‚ö†Ô∏è Continuing workflow to allow other builds to complete and generate summary"
  
  update-release:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always() && needs.determine-build-parameters.outputs.release_exists == 'true'
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Update release with build status
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "üìù Updating release $VERSION with build information"
          
          # Get current release notes
          gh release view "$VERSION" --json body -q .body > current_notes.md
          
          # Create updated notes with build status
          cat > updated_notes.md << EOF
          $(grep -B 1000 "## üì¶ Build Status" current_notes.md | head -n -2 || cat current_notes.md)
          
          ## üì¶ Build Status
          
          ‚úÖ **Bitrise builds triggered** at $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ### Triggered Builds:
          EOF
          
          echo '```' >> updated_notes.md
          echo "$APPS" | jq -r '.[]' | while read app; do
            APP_LOWER=$(echo "$app" | tr '[:upper:]' '[:lower:]' | tr -d '.')
            echo "‚úì $app" >> updated_notes.md
            echo "  - ${APP_LOWER}-android-staging" >> updated_notes.md
            echo "  - ${APP_LOWER}-android-production" >> updated_notes.md
            echo "  - ${APP_LOWER}-ios-staging" >> updated_notes.md
            echo "  - ${APP_LOWER}-ios-production" >> updated_notes.md
          done
          echo '```' >> updated_notes.md
          
          cat >> updated_notes.md << EOF
          
          **Build Details:**
          - Build Workflow: [Run #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - Release Branch: \`release/$VERSION\`
          - Triggered by: @${{ github.actor }}
          - Total Builds: $(echo "$APPS" | jq -r '. | length * 4') (4 per app: android/ios √ó staging/production)
          
          > **Note**: Check Bitrise for individual build statuses and artifacts.
          
          EOF
          
          # Add the rest of the original notes if there's content after Build Status
          if grep -A 1000 "## üì¶ Build Status" current_notes.md | tail -n +3 | grep -q "^---"; then
            echo "" >> updated_notes.md
            grep -A 1000 "^---" current_notes.md >> updated_notes.md
          else
            echo "---" >> updated_notes.md
            echo "*This release was automatically generated by GitHub Actions*" >> updated_notes.md
          fi
          
          # Update the release
          gh release edit "$VERSION" --notes-file updated_notes.md
          
          echo "‚úÖ Release $VERSION updated with Bitrise build status"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  summary:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Create job summary
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          RELEASE_EXISTS="${{ needs.determine-build-parameters.outputs.release_exists }}"
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # üöÄ Bitrise Build Summary
          
          ## üìã Build Information
          
          | Field | Value |
          |-------|-------|
          | **Version** | \`$VERSION\` |
          | **Release Branch** | \`release/$VERSION\` |
          | **Version Source** | ${{ github.event.inputs.version_source }} |
          | **Release Exists** | $([ "$RELEASE_EXISTS" == "true" ] && echo "‚úÖ Yes" || echo "‚ö†Ô∏è No") |
          | **App Selection** | ${{ github.event.inputs.app_selection }} |
          | **Triggered by** | @${{ github.actor }} |
          | **Workflow Run** | #${{ github.run_number }} |
          
          ## üì¶ Bitrise Workflows Triggered
          
          | App | Platform | Environment | Workflow | Build # | Status |
          |-----|----------|-------------|----------|---------|--------|
          EOF
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            APP_LOWER=$(echo "$app" | tr '[:upper:]' '[:lower:]' | tr -d '.')
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                
                if [ -f "$BUILD_FILE" ]; then
                  BUILD_DATA=$(cat "$BUILD_FILE")
                  BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
                  INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
                  STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
                  COMPLETED=$(echo "$BUILD_DATA" | jq -r '.completed')
                  
                  # Format build number with hyperlink if available (Android only)
                  if [ "$platform" = "android" ] && [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                    BUILD_DISPLAY="[#$BUILD_NUM]($INSTALL_URL)"
                  else
                    BUILD_DISPLAY="\`#$BUILD_NUM\`"
                  fi
                  
                  # Format status
                  case "$STATUS" in
                    "success") STATUS_DISPLAY="‚úÖ SUCCESS" ;;
                    "error") STATUS_DISPLAY="‚ùå FAILED" ;;
                    "aborted") STATUS_DISPLAY="‚ö†Ô∏è ABORTED" ;;
                    "timeout") STATUS_DISPLAY="‚è±Ô∏è TIMEOUT" ;;
                    *) STATUS_DISPLAY="‚ùì $STATUS" ;;
                  esac
                  
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | $BUILD_DISPLAY | $STATUS_DISPLAY |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| $app | $platform | $env | ${APP_LOWER}-${platform}-${env} | _No data_ | ‚ùì Unknown |" >> $GITHUB_STEP_SUMMARY
                fi
              done
            done
          done
          
          # Calculate total builds and overall status
          TOTAL_APPS=$(echo "$APPS" | jq -r '. | length')
          TOTAL_BUILDS=$((TOTAL_APPS * 4))
          
          # Count build results by status
          SUCCESS_COUNT=0
          FAILED_COUNT=0
          ABORTED_COUNT=0
          TIMEOUT_COUNT=0
          UNKNOWN_COUNT=0
          
          for app in $(echo "$APPS" | jq -r '.[]'); do
            for platform in android ios; do
              for env in staging production; do
                BUILD_FILE="build-results/${app}-${platform}-${env}.json"
                if [ -f "$BUILD_FILE" ]; then
                  STATUS=$(cat "$BUILD_FILE" | jq -r '.status')
                  case "$STATUS" in
                    "success") SUCCESS_COUNT=$((SUCCESS_COUNT + 1)) ;;
                    "error") FAILED_COUNT=$((FAILED_COUNT + 1)) ;;
                    "aborted") ABORTED_COUNT=$((ABORTED_COUNT + 1)) ;;
                    "timeout") TIMEOUT_COUNT=$((TIMEOUT_COUNT + 1)) ;;
                    *) UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1)) ;;
                  esac
                else
                  UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1))
                fi
              done
            done
          done
          
          # Determine overall workflow status
          if [ $FAILED_COUNT -gt 0 ] || [ $ABORTED_COUNT -gt 0 ] || [ $TIMEOUT_COUNT -gt 0 ]; then
            if [ $SUCCESS_COUNT -gt 0 ]; then
              OVERALL_STATUS="‚ö†Ô∏è **PARTIAL SUCCESS** - Some builds failed but workflow continued"
            else
              OVERALL_STATUS="‚ùå **FAILED** - All builds failed"
            fi
          elif [ $SUCCESS_COUNT -eq $TOTAL_BUILDS ]; then
            OVERALL_STATUS="‚úÖ **SUCCESS** - All builds completed successfully"
          else
            OVERALL_STATUS="üîÑ **IN PROGRESS** - Some builds still processing"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          
          ## üìä Summary
          
          - **Overall Status**: $OVERALL_STATUS
          - **Total Apps**: $TOTAL_APPS
          - **Builds per App**: 4 (2 platforms √ó 2 environments)
          - **Total Builds Triggered**: $TOTAL_BUILDS
          - **Successful**: $SUCCESS_COUNT
          - **Failed**: $FAILED_COUNT
          - **Aborted**: $ABORTED_COUNT
          - **Timeout**: $TIMEOUT_COUNT
          - **Unknown/Pending**: $UNKNOWN_COUNT
          
          ## üîó Links
          
          EOF
          
          if [ "$RELEASE_EXISTS" == "true" ]; then
            echo "- [View Release](https://github.com/${{ github.repository }}/releases/tag/$VERSION)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ö†Ô∏è No release found for version $VERSION" >> $GITHUB_STEP_SUMMARY
            echo "- [Create Release](https://github.com/${{ github.repository }}/actions/workflows/create-release-version.yml)" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          - [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Bitrise Dashboard](https://app.bitrise.io/dashboard)
          
          ## ‚ö†Ô∏è Important Notes
          
          1. **Build Numbers**: Individual Bitrise build numbers are shown in the build details above
          2. **Install Pages**: Public install page links are available in the build details above (after build completion)
          3. **Check Bitrise** for individual build statuses and download artifacts
          4. **Release Branch**: All builds are from \`release/$VERSION\`
          5. **Workflow Naming**: Follows pattern \`{app}-{platform}-{environment}\`
          
          ---
          *Builds triggered at $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF
  
  slack-notification:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all build results
        uses: actions/download-artifact@v4
        with:
          pattern: build-result-*
          merge-multiple: true
          path: build-results/
      
      - name: Prepare Slack message
        id: slack-message
        run: |
          VERSION="${{ needs.determine-build-parameters.outputs.version }}"
          
          echo "üì± Preparing Slack message for release $VERSION"
                   
          # Process build results by app
          APPS='${{ needs.determine-build-parameters.outputs.apps }}'
          
          echo "$APPS" | jq -r '.[]' | while read app; do
            echo "Processing app: $app"
            
            # Process builds for this app
            STAGING_ANDROID="N/A"
            STAGING_IOS="N/A"
            PROD_ANDROID="N/A"
            PROD_IOS="N/A"
            
            # Check for Android staging - with install page links
            if [ -f "build-results/${app}-android-staging.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-android-staging.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              
              if [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                STAGING_ANDROID="<$INSTALL_URL|$BUILD_NUM>"
              else
                STAGING_ANDROID="$BUILD_NUM"
              fi
            fi
            
            # Check for iOS staging - no install page expected
            if [ -f "build-results/${app}-ios-staging.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-ios-staging.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              # iOS builds don't need install URLs
              STAGING_IOS="$BUILD_NUM"
            fi
            
            # Check for Android production - with install page links
            if [ -f "build-results/${app}-android-production.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-android-production.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              INSTALL_URL=$(echo "$BUILD_DATA" | jq -r '.install_url // empty')
              STATUS=$(echo "$BUILD_DATA" | jq -r '.status')
              
              if [ "$STATUS" = "success" ] && [ -n "$INSTALL_URL" ] && [ "$INSTALL_URL" != "null" ] && [ "$INSTALL_URL" != "empty" ]; then
                PROD_ANDROID="<$INSTALL_URL|$BUILD_NUM>"
              else
                PROD_ANDROID="$BUILD_NUM"
              fi
            fi
            
            # Check for iOS production - no install page expected
            if [ -f "build-results/${app}-ios-production.json" ]; then
              BUILD_DATA=$(cat "build-results/${app}-ios-production.json")
              BUILD_NUM=$(echo "$BUILD_DATA" | jq -r '.build_number')
              # iOS builds don't need install URLs
              PROD_IOS="$BUILD_NUM"
            fi
            
            # Append to message file
            cat >> slack_message.txt << EOF
          ‚Ä¢ *$app*
            ‚ñ∏ *Staging:* :android: $STAGING_ANDROID  :appleinc: $STAGING_IOS
            ‚ñ∏ *Production:* :android: $PROD_ANDROID  :appleinc: $PROD_IOS
          EOF
          
          done
          
          # Add footer
          cat >> slack_message.txt << EOF
          
          :rocket: *Release:* $VERSION
          :github: *Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run #${{ github.run_number }}>
          EOF
          
          echo "Final Slack message:"
          cat slack_message.txt
      
      - name: Send Slack notification
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "‚ö†Ô∏è SLACK_WEBHOOK_URL not configured - skipping Slack notification"
            exit 0
          fi
          
          echo "üì§ Sending Slack notification..."
          
          # Read the message and escape for JSON
          MESSAGE_CONTENT=$(cat slack_message.txt | jq -Rs .)
          
          # Determine channel (use override if specified, otherwise webhook default)
          CHANNEL_OVERRIDE=""
          if [ -n "$SLACK_CHANNEL" ]; then
            CHANNEL_OVERRIDE=",\"channel\": \"$SLACK_CHANNEL\""
            echo "üéØ Overriding channel to: $SLACK_CHANNEL"
          else
            echo "üìç Using webhook default channel"
          fi
          
          # Create JSON payload with optional channel override
          PAYLOAD=$(cat << EOF
          {
            "text": "üöÄ Build Results for Release ${{ needs.determine-build-parameters.outputs.version }}"$CHANNEL_OVERRIDE,
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": $MESSAGE_CONTENT
                }
              }
            ]
          }
          EOF
          )
          
          echo "Payload preview:"
          echo "$PAYLOAD" | jq .
          
          # Send to Slack
          RESPONSE=$(curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL")
          
          if [ "$RESPONSE" = "ok" ]; then
            echo "‚úÖ Slack notification sent successfully!"
          else
            echo "‚ùå Failed to send Slack notification. Response: $RESPONSE"
            exit 1
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL }}
  
  cancel-bitrise-builds:
    needs: [determine-build-parameters, build-apps]
    runs-on: ubuntu-latest
    if: cancelled()
    
    steps:
      - name: Download build slug artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-slug-*
          merge-multiple: true
          path: build-slugs/
        continue-on-error: true
      
      - name: Cancel Bitrise builds
        env:
          BITRISE_APP_ID: ${{ secrets.BITRISE_PROJECT_SLUG }}
          BITRISE_ACCESS_TOKEN: ${{ secrets.BITRISE_ACCESS_TOKEN }}
        run: |
          echo "üö´ Workflow cancelled - attempting to cancel Bitrise builds..."
          
          CANCELLED_COUNT=0
          TOTAL_BUILDS=0
          
          if [ ! -d "build-slugs" ]; then
            echo "‚ö†Ô∏è No build slug artifacts found - builds may not have been triggered yet"
            exit 0
          fi
          
          # Process each build slug file
          for build_file in build-slugs/*.json; do
            if [ ! -f "$build_file" ]; then
              echo "‚ö†Ô∏è No build slug files found"
              continue
            fi
            
            TOTAL_BUILDS=$((TOTAL_BUILDS + 1))
            
            # Extract build information
            BUILD_DATA=$(cat "$build_file")
            BUILD_SLUG=$(echo "$BUILD_DATA" | jq -r '.build_slug')
            APP=$(echo "$BUILD_DATA" | jq -r '.app')
            PLATFORM=$(echo "$BUILD_DATA" | jq -r '.platform')
            ENVIRONMENT=$(echo "$BUILD_DATA" | jq -r '.environment')
            BUILD_URL=$(echo "$BUILD_DATA" | jq -r '.build_url')
            
            echo ""
            echo "üì± Processing: $APP ($PLATFORM/$ENVIRONMENT)"
            echo "üîó Build Slug: $BUILD_SLUG"
            echo "üåê Build URL: $BUILD_URL"
            
            # Check current build status first
            echo "üîç Checking current build status..."
            STATUS_RESPONSE=$(curl -s -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
              "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds/${BUILD_SLUG}")
            
            if ! echo "$STATUS_RESPONSE" | jq empty 2>/dev/null; then
              echo "‚ùå Failed to get build status (invalid JSON response)"
              continue
            fi
            
            BUILD_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.data.status_text // "unknown"')
            FINISHED_AT=$(echo "$STATUS_RESPONSE" | jq -r '.data.finished_at // null')
            
            echo "üìä Current Status: $BUILD_STATUS"
            
            # Skip if build is already finished
            if [ "$BUILD_STATUS" = "success" ] || [ "$BUILD_STATUS" = "error" ] || [ "$BUILD_STATUS" = "aborted" ] || [ "$FINISHED_AT" != "null" ]; then
              echo "‚úÖ Build already finished ($BUILD_STATUS) - skipping cancellation"
              continue
            fi
            
            # Attempt to cancel the build
            echo "üö´ Attempting to cancel build..."
            CANCEL_RESPONSE=$(curl -s -X POST -w "HTTPSTATUS:%{http_code}" \
              -H "Authorization: token ${BITRISE_ACCESS_TOKEN}" \
              -H "Content-Type: application/json" \
              "https://api.bitrise.io/v0.1/apps/${BITRISE_APP_ID}/builds/${BUILD_SLUG}/abort")
            
            # Extract HTTP status and response
            HTTP_STATUS=$(echo "$CANCEL_RESPONSE" | grep -o 'HTTPSTATUS:[0-9]*' | cut -d: -f2)
            CANCEL_DATA=$(echo "$CANCEL_RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
            
            echo "üåê HTTP Status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Successfully cancelled Bitrise build for $APP ($PLATFORM/$ENVIRONMENT)"
              CANCELLED_COUNT=$((CANCELLED_COUNT + 1))
            elif [ "$HTTP_STATUS" = "400" ]; then
              echo "‚ö†Ô∏è Build cannot be cancelled (likely already finished or not running)"
            elif [ "$HTTP_STATUS" = "404" ]; then
              echo "‚ùå Build not found - may have been already cancelled or removed"
            else
              echo "‚ùå Failed to cancel build (HTTP $HTTP_STATUS)"
              echo "Response: $CANCEL_DATA"
            fi
          done
          
          echo ""
          echo "üìä Cancellation Summary:"
          echo "  Total builds processed: $TOTAL_BUILDS"
          echo "  Successfully cancelled: $CANCELLED_COUNT"
          echo "  Skipped (already finished): $((TOTAL_BUILDS - CANCELLED_COUNT))"
          
          if [ $CANCELLED_COUNT -gt 0 ]; then
            echo "‚úÖ Cancelled $CANCELLED_COUNT Bitrise build(s) due to workflow cancellation"
          else
            echo "‚ÑπÔ∏è No running builds found to cancel"
          fi
      
      - name: Create cancellation summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # üö´ Workflow Cancelled - Bitrise Build Cleanup
          
          ## üìã Cancellation Information
          
          | Field | Value |
          |-------|-------|
          | **Cancelled At** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |
          | **Version** | \`${{ needs.determine-build-parameters.outputs.version }}\` |
          | **Triggered by** | @${{ github.actor }} |
          | **Workflow Run** | #${{ github.run_number }} |
          
          ## üö´ Build Cancellation Status
          
          The workflow was cancelled and we attempted to cancel any running Bitrise builds to prevent unnecessary resource usage.
          
          **Note**: 
          - Builds that were already completed (success/error/aborted) were left as-is
          - Only running or queued builds were cancelled
          - Check the job logs above for detailed cancellation results
          
          ## üîó Links
          
          - [View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Bitrise Dashboard](https://app.bitrise.io/dashboard)
          
          ---
          *Cancellation processed at $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF